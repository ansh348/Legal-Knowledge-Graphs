<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Legal Reasoning Graph Visualizer ‚Äî v4 Proposal</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'IBM Plex Sans', system-ui, sans-serif; background: #0f0f1a; overflow: hidden; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
    ::-webkit-scrollbar-thumb { background: rgba(168,85,247,0.3); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(168,85,247,0.5); }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback, useMemo } = React;

    // ============================================================================
    // SAMPLE DATA
    // ============================================================================
    const sampleGraph = {
      case_id: "sample_case_001",
      case_name: "State of Maharashtra v. Respondent",
      case_year: 2024,
      court: "Supreme Court of India",
      judges: ["Justice A. Kumar", "Justice B. Singh"],
      facts: [
        { id: "fact_1", type: "fact", text: "The petitioner filed a writ petition challenging the constitutional validity of Section 6A of the Citizenship Act.", fact_type: "procedural", confidence: "high", anchor: { display_location: "Para 1", surface_text: "The petitioner filed a writ petition challenging the constitutional validity of Section 6A of the Citizenship Act, 1955.", doc_id: "doc1", start_char: 0, end_char: 120, text_hash: "abc123" } },
        { id: "fact_2", type: "fact", text: "The respondent was granted citizenship under the impugned provision in 2015.", fact_type: "material", confidence: "high", anchor: { display_location: "Para 3", surface_text: "The respondent was granted citizenship under the impugned provision in the year 2015.", doc_id: "doc1", start_char: 245, end_char: 330, text_hash: "def456" } },
        { id: "fact_3", type: "fact", text: "The petitioner argued that Section 6A creates an unreasonable classification violating Article 14.", fact_type: "material", confidence: "high", anchor: { display_location: "Para 5", surface_text: "It was contended that Section 6A creates an unreasonable classification which violates Article 14 of the Constitution.", doc_id: "doc1", start_char: 500, end_char: 618 } },
      ],
      concepts: [
        { id: "concept_1", type: "concept", concept_id: "DOCTRINE_REASONABLE_CLASSIFICATION_ARTICLE_14_TWIN_TEST", relevance: "central", kind: "standard", interpretation: "Twin test of intelligible differentia and rational nexus", anchor: { display_location: "Para 12" } },
        { id: "concept_2", type: "concept", concept_id: "DOCTRINE_MANIFEST_ARBITRARINESS", relevance: "central", kind: "standard", anchor: { display_location: "Para 15" } },
        { id: "concept_3", type: "concept", concept_id: "STATUTE_CITIZENSHIP_ACT_S6A", unlisted_label: "Section 6A, Citizenship Act, 1955", relevance: "central", kind: "statute_section", anchor: { display_location: "Para 2" } },
      ],
      issues: [
        { id: "issue_1", type: "issue", text: "Whether Section 6A of the Citizenship Act violates Article 14 of the Constitution?", issue_number: 1, framed_by: "court", answer: "no", primary_concepts: ["concept_1", "concept_2"], anchor: { display_location: "Para 8" } },
        { id: "issue_2", type: "issue", text: "Whether there exists an intelligible differentia between the classes created by Section 6A?", issue_number: 2, framed_by: "court", answer: "yes", primary_concepts: ["concept_1"], anchor: { display_location: "Para 9" } },
      ],
      arguments: [
        { id: "arg_1", type: "argument", claim: "Section 6A creates arbitrary classification based on geography and time period without rational basis", actor: "petitioner", schemes: ["rule_application"], court_response: "rejected", confidence: "high", anchor: { display_location: "Para 20" } },
        { id: "arg_2", type: "argument", claim: "The classification in Section 6A has intelligible differentia based on historical context of Assam Accord", actor: "respondent", schemes: ["rule_application", "purposive"], court_response: "accepted", confidence: "high", anchor: { display_location: "Para 25" } },
        { id: "arg_3", type: "argument", claim: "The cut-off dates have rational nexus with the object of controlling illegal immigration", actor: "court", schemes: ["rule_application", "policy_consequence"], court_response: "accepted", confidence: "high", anchor: { display_location: "Para 45" } },
      ],
      holdings: [
        { id: "holding_1", type: "holding", text: "Section 6A satisfies the twin test under Article 14 - the classification is based on intelligible differentia having rational nexus with the object sought to be achieved.", resolves_issue: "issue_1", is_ratio: true, novel: false, reasoning_summary: "Historical context of Assam Accord and unique demographic situation justifies the classification", schemes: ["rule_application"], confidence: "high", anchor: { display_location: "Para 52" } },
        { id: "holding_2", type: "holding", text: "The cut-off date of 1966 and 1971 are not arbitrary but based on the Assam Accord which was a political settlement.", resolves_issue: "issue_2", is_ratio: true, novel: false, schemes: ["purposive"], confidence: "high", anchor: { display_location: "Para 55" } },
      ],
      precedents: [
        { id: "prec_1", type: "precedent", citation: "Ram Krishna Dalmia v. Justice Tendolkar (1958)", case_name: "Ram Krishna Dalmia", case_year: 1958, treatment: "followed", relevance: "central", cited_proposition: "Classification must be founded on intelligible differentia which distinguishes grouped from those left out", anchor: { display_location: "Para 30" } },
        { id: "prec_2", type: "precedent", citation: "Shayara Bano v. Union of India (2017)", case_name: "Shayara Bano", case_year: 2017, treatment: "distinguished", relevance: "supporting", cited_proposition: "Manifest arbitrariness as a ground for striking down legislation", anchor: { display_location: "Para 35" } },
      ],
      justification_sets: [
        { id: "js_1", type: "justification_set", target_id: "holding_1", logic: "and", label: "Primary justification for upholding Section 6A", is_primary: true, confidence: "high" },
        { id: "js_2", type: "justification_set", target_id: "holding_2", logic: "and", label: "Historical basis justification", is_primary: true, confidence: "high" },
      ],
      outcome: {
        id: "outcome", type: "outcome", disposition: "dismissed", binary: "rejected",
        relief_summary: "The writ petition is dismissed. Section 6A of the Citizenship Act is held to be constitutionally valid.",
        costs: "none", directions: [], anchor: { display_location: "Para 60" }
      },
      edges: [
        { id: "e1", source: "fact_1", target: "issue_1", relation: "triggers", confidence: "high", strength: "strong" },
        { id: "e2", source: "fact_3", target: "arg_1", relation: "supports", confidence: "high", strength: "strong" },
        { id: "e3", source: "concept_1", target: "arg_1", relation: "grounds", confidence: "high", strength: "strong" },
        { id: "e4", source: "concept_1", target: "arg_2", relation: "grounds", confidence: "high", strength: "strong" },
        { id: "e5", source: "arg_2", target: "arg_1", relation: "rebuts", confidence: "high", strength: "strong" },
        { id: "e6", source: "prec_1", target: "arg_3", relation: "supports", confidence: "high", strength: "strong", support_group_ids: ["js_1"] },
        { id: "e7", source: "concept_1", target: "holding_1", relation: "grounds", confidence: "high", strength: "strong", support_group_ids: ["js_1"], is_critical: true },
        { id: "e8", source: "arg_3", target: "holding_1", relation: "supports", confidence: "high", strength: "strong", support_group_ids: ["js_1"] },
        { id: "e9", source: "holding_1", target: "issue_1", relation: "resolves", confidence: "high", strength: "strong" },
        { id: "e10", source: "holding_2", target: "issue_2", relation: "resolves", confidence: "high", strength: "strong" },
        { id: "e11", source: "holding_1", target: "outcome", relation: "determines", confidence: "high", strength: "strong", is_critical: true },
        { id: "e12", source: "holding_2", target: "outcome", relation: "contributes_to", confidence: "high", strength: "moderate" },
        { id: "e13", source: "prec_2", target: "arg_1", relation: "supports", confidence: "medium", strength: "weak" },
        { id: "e14", source: "concept_2", target: "issue_1", relation: "addresses", confidence: "high", strength: "strong" },
        { id: "e15", source: "fact_2", target: "concept_3", relation: "triggers", confidence: "high", strength: "strong" },
      ],
      reasoning_chains: [
        {
          id: "chain_1", issue_id: "issue_1",
          fact_ids: ["fact_1", "fact_3"], concept_ids: ["concept_1", "concept_2"],
          argument_ids: ["arg_1", "arg_2", "arg_3"], holding_id: "holding_1",
          edge_ids: ["e1", "e3", "e5", "e7", "e9", "e11"],
          justification_set_id: "js_1", critical_nodes: ["concept_1", "holding_1"],
          narrative: "The petitioner challenged Section 6A on Article 14 grounds, arguing arbitrary classification. The court applied the reasonable classification test from Ram Krishna Dalmia, finding that the Assam Accord's historical context provided intelligible differentia with rational nexus to the legislative object."
        }
      ],
      _meta: {
        schema_version: "2.1.2", quality_tier: "gold",
        extraction_model: "grok-4-1-fast-reasoning",
        extraction_timestamp: "2024-02-04T10:30:00Z",
        retry_attempts: 0, validation_warnings: []
      }
    };

    // ============================================================================
    // CONFIGURATION & CONSTANTS
    // ============================================================================
    const NODE_COLORS = {
      fact: { bg: '#1e3a5f', border: '#3b82f6', text: '#93c5fd', icon: 'üìã' },
      concept: { bg: '#3d1f5c', border: '#a855f7', text: '#d8b4fe', icon: '‚öñÔ∏è' },
      issue: { bg: '#5c3d1f', border: '#f59e0b', text: '#fcd34d', icon: '‚ùì' },
      argument: { bg: '#1f5c3d', border: '#10b981', text: '#6ee7b7', icon: 'üí¨' },
      holding: { bg: '#5c1f1f', border: '#ef4444', text: '#fca5a5', icon: 'üìú' },
      precedent: { bg: '#4a4a1f', border: '#eab308', text: '#fef08a', icon: 'üìö' },
      outcome: { bg: '#1f4a4a', border: '#14b8a6', text: '#5eead4', icon: 'üéØ' },
      justification_set: { bg: '#2d2d4a', border: '#818cf8', text: '#c7d2fe', icon: '‚óÜ' },
    };

    const BASE_EDGE_COLORS = {
      supports: '#10b981', rebuts: '#ef4444', undercuts: '#f59e0b',
      triggers: '#3b82f6', grounds: '#a855f7', establishes: '#06b6d4',
      resolves: '#14b8a6', determines: '#ec4899', contributes_to: '#8b5cf6',
      addresses: '#6366f1', attacks: '#dc2626', follows: '#22c55e',
      applies: '#0ea5e9', distinguishes: '#f97316', requires: '#f472b6',
      claims_satisfies: '#34d399', partially_satisfies: '#a78bfa',
      supports_arg: '#4ade80', responds_to: '#fb923c', negates: '#f87171',
      specializes: '#38bdf8', satisfies: '#2dd4bf',
      default: '#6b7280'
    };

    const QUALITY_COLORS = {
      gold: { bg: '#fef3c7', border: '#f59e0b', text: '#92400e' },
      silver: { bg: '#f3f4f6', border: '#9ca3af', text: '#374151' },
      bronze: { bg: '#fed7aa', border: '#ea580c', text: '#9a3412' },
      reject: { bg: '#fee2e2', border: '#ef4444', text: '#991b1b' }
    };

    const TREATMENT_COLORS = {
      followed: { bg: '#065f46', border: '#10b981', text: '#6ee7b7' },
      applied: { bg: '#065f46', border: '#10b981', text: '#6ee7b7' },
      distinguished: { bg: '#78350f', border: '#f59e0b', text: '#fcd34d' },
      overruled: { bg: '#7f1d1d', border: '#ef4444', text: '#fca5a5' },
      doubted: { bg: '#713f12', border: '#eab308', text: '#fef08a' },
      explained: { bg: '#1e3a5f', border: '#3b82f6', text: '#93c5fd' },
      cited: { bg: '#3d3d3d', border: '#9ca3af', text: '#e5e7eb' }
    };

    const ANSWER_COLORS = {
      yes: { bg: '#065f46', border: '#10b981', text: '#6ee7b7' },
      no: { bg: '#7f1d1d', border: '#ef4444', text: '#fca5a5' },
      partly: { bg: '#78350f', border: '#f59e0b', text: '#fcd34d' },
      not_decided: { bg: '#3d3d3d', border: '#9ca3af', text: '#e5e7eb' }
    };

    const SCHEME_COLORS = {
      rule_application: { bg: '#1e3a5f', border: '#3b82f6', text: '#93c5fd' },
      rule_exception: { bg: '#3d1f5c', border: '#a855f7', text: '#d8b4fe' },
      precedent_following: { bg: '#065f46', border: '#10b981', text: '#6ee7b7' },
      precedent_analogy: { bg: '#1f5c3d', border: '#14b8a6', text: '#5eead4' },
      precedent_distinction: { bg: '#78350f', border: '#f59e0b', text: '#fcd34d' },
      textual: { bg: '#4a4a1f', border: '#eab308', text: '#fef08a' },
      purposive: { bg: '#5c1f3d', border: '#ec4899', text: '#f9a8d4' },
      harmonious: { bg: '#1f4a4a', border: '#06b6d4', text: '#67e8f9' },
      proportionality: { bg: '#5c3d1f', border: '#f97316', text: '#fdba74' },
      balancing: { bg: '#3d1f5c', border: '#8b5cf6', text: '#c4b5fd' },
      evidence_sufficiency: { bg: '#1e3a5f', border: '#0ea5e9', text: '#7dd3fc' },
      evidence_credibility: { bg: '#1e3a5f', border: '#0284c7', text: '#38bdf8' },
      procedural: { bg: '#3d3d3d', border: '#9ca3af', text: '#e5e7eb' },
      jurisdiction: { bg: '#5c1f1f', border: '#dc2626', text: '#fca5a5' },
      limitation: { bg: '#713f12', border: '#ca8a04', text: '#fde047' },
      policy_consequence: { bg: '#1f5c3d', border: '#22c55e', text: '#86efac' },
      public_interest: { bg: '#065f46', border: '#059669', text: '#6ee7b7' },
      natural_justice: { bg: '#4a4a1f', border: '#a3e635', text: '#d9f99d' },
      other: { bg: '#3d3d3d', border: '#6b7280', text: '#d1d5db' }
    };

    const THEMES = {
      dark: {
        name: 'dark', bg: 'linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%)',
        headerBg: 'linear-gradient(90deg, rgba(30,30,50,0.95) 0%, rgba(40,30,60,0.95) 100%)',
        sidebarBg: 'rgba(20,20,35,0.95)', borderColor: 'rgba(168,85,247,0.3)',
        textPrimary: '#e5e7eb', textSecondary: '#9ca3af', textMuted: '#6b7280',
        inputBg: 'rgba(255,255,255,0.05)', inputBorder: 'rgba(255,255,255,0.1)',
        cardBg: 'rgba(255,255,255,0.02)', cardBorder: 'rgba(255,255,255,0.1)'
      },
      light: {
        name: 'light', bg: 'linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #cbd5e1 100%)',
        headerBg: 'linear-gradient(90deg, rgba(255,255,255,0.95) 0%, rgba(248,250,252,0.95) 100%)',
        sidebarBg: 'rgba(255,255,255,0.95)', borderColor: 'rgba(100,116,139,0.3)',
        textPrimary: '#1e293b', textSecondary: '#475569', textMuted: '#94a3b8',
        inputBg: 'rgba(0,0,0,0.05)', inputBorder: 'rgba(0,0,0,0.1)',
        cardBg: 'rgba(0,0,0,0.02)', cardBorder: 'rgba(0,0,0,0.1)'
      }
    };

    // ============================================================================
    // SUB-COMPONENTS
    // ============================================================================
    function PropertyRow({ label, value, theme }) {
      return (
        <div style={{ display: 'flex', justifyContent: 'space-between', padding: '8px 12px', background: 'rgba(255,255,255,0.02)', borderRadius: '6px', fontSize: '13px' }}>
          <span style={{ color: '#9ca3af' }}>{label}</span>
          <span style={{ color: '#e5e7eb', textAlign: 'right', maxWidth: '60%', wordBreak: 'break-word' }}>{String(value)}</span>
        </div>
      );
    }

    function EdgeChip({ edge, direction, nodeMap, getNodeText, onClick }) {
      const otherNodeId = direction === 'in' ? edge.source : edge.target;
      const otherNode = nodeMap.get(otherNodeId);
      const color = BASE_EDGE_COLORS[edge.relation] || BASE_EDGE_COLORS.default;
      return (
        <div onClick={onClick} style={{
          display: 'flex', alignItems: 'center', gap: '8px', padding: '8px 12px', marginBottom: '6px',
          background: 'rgba(255,255,255,0.03)', borderLeft: `3px solid ${color}`,
          borderRadius: '0 6px 6px 0', cursor: 'pointer', fontSize: '12px'
        }}>
          <span style={{ color }}>{direction === 'in' ? '‚Üê' : '‚Üí'}</span>
          <span style={{ color: '#9ca3af', textTransform: 'uppercase', fontSize: '10px' }}>{edge.relation}</span>
          <span style={{ color: '#e5e7eb', flex: 1, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
            {otherNode ? getNodeText(otherNode).substring(0, 30) : otherNodeId}
          </span>
        </div>
      );
    }

    function ToulminView({ argumentId, getToulmin, getNodeText }) {
      const toulmin = getToulmin(argumentId);
      if (!toulmin) return null;
      const sections = [
        { key: 'grounds', label: 'Grounds (Facts)', color: NODE_COLORS.fact, icon: 'üìã' },
        { key: 'warrants', label: 'Warrants (Concepts)', color: NODE_COLORS.concept, icon: '‚öñÔ∏è' },
        { key: 'backing', label: 'Backing (Precedents)', color: NODE_COLORS.precedent, icon: 'üìö' },
        { key: 'rebuttals', label: 'Rebuttals', color: { border: '#ef4444', text: '#fca5a5' }, icon: '‚öîÔ∏è' },
      ];
      return (
        <div style={{ marginBottom: '20px' }}>
          <h4 style={{ margin: '0 0 12px 0', fontSize: '13px', color: '#9ca3af', textTransform: 'uppercase' }}>Toulmin Structure</h4>
          {sections.map(sec => (
            toulmin[sec.key]?.length > 0 && (
              <div key={sec.key} style={{ marginBottom: '12px' }}>
                <div style={{ fontSize: '11px', color: sec.color.text, marginBottom: '6px' }}>{sec.icon} {sec.label}</div>
                {toulmin[sec.key].map(node => (
                  <div key={node.id} style={{ padding: '8px 10px', marginBottom: '4px', background: 'rgba(255,255,255,0.02)', borderLeft: `2px solid ${sec.color.border}`, borderRadius: '0 4px 4px 0', fontSize: '12px' }}>
                    {getNodeText(node).substring(0, 80)}
                  </div>
                ))}
              </div>
            )
          ))}
          {sections.every(sec => !toulmin[sec.key]?.length) && (
            <div style={{ fontSize: '12px', color: '#4b5563' }}>No Toulmin elements found</div>
          )}
        </div>
      );
    }

    // ============================================================================
    // VIRTUALIZED TABLE
    // ============================================================================
    function VirtualizedTable({ nodes, selectedNode, setSelectedNode, getNodeType, getNodeText, theme, currentTheme }) {
      const containerRef = useRef(null);
      const [scrollTop, setScrollTop] = useState(0);
      const [containerHeight, setContainerHeight] = useState(600);
      const rowHeight = 50;
      const bufferRows = 5;

      useEffect(() => {
        if (containerRef.current) setContainerHeight(containerRef.current.clientHeight - 50);
      }, []);

      const totalHeight = nodes.length * rowHeight;
      const startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - bufferRows);
      const endIndex = Math.min(nodes.length, Math.ceil((scrollTop + containerHeight) / rowHeight) + bufferRows);
      const visibleNodes = nodes.slice(startIndex, endIndex);
      const offsetY = startIndex * rowHeight;

      return (
        <div ref={containerRef} style={{ flex: 1, overflow: 'hidden', display: 'flex', flexDirection: 'column' }}>
          <div style={{ display: 'flex', background: theme === 'dark' ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)', borderBottom: `1px solid ${currentTheme.cardBorder}`, fontSize: '12px', fontWeight: 600, color: currentTheme.textSecondary, position: 'sticky', top: 0, zIndex: 10 }}>
            <div style={{ width: '120px', padding: '12px', flexShrink: 0 }}>Type</div>
            <div style={{ width: '140px', padding: '12px', flexShrink: 0 }}>ID</div>
            <div style={{ flex: 1, padding: '12px', minWidth: '200px' }}>Content</div>
            <div style={{ width: '100px', padding: '12px', flexShrink: 0 }}>Confidence</div>
            <div style={{ width: '100px', padding: '12px', flexShrink: 0 }}>Location</div>
          </div>
          <div style={{ flex: 1, overflow: 'auto' }} onScroll={(e) => setScrollTop(e.target.scrollTop)}>
            <div style={{ height: totalHeight, position: 'relative' }}>
              <div style={{ position: 'absolute', top: offsetY, left: 0, right: 0 }}>
                {visibleNodes.map(node => {
                  const type = getNodeType(node);
                  const colors = NODE_COLORS[type] || NODE_COLORS.fact;
                  return (
                    <div key={node.id} onClick={() => setSelectedNode(node)} style={{
                      display: 'flex', height: rowHeight, cursor: 'pointer',
                      background: selectedNode?.id === node.id ? 'rgba(168,85,247,0.2)' : 'transparent',
                      borderBottom: `1px solid ${currentTheme.cardBorder}`, alignItems: 'center', transition: 'background 0.15s'
                    }}>
                      <div style={{ width: '120px', padding: '8px 12px', flexShrink: 0 }}>
                        <span style={{ display: 'inline-block', padding: '4px 8px', background: colors.bg, border: `1px solid ${colors.border}`, borderRadius: '10px', color: colors.text, fontSize: '10px' }}>{colors.icon} {type}</span>
                      </div>
                      <div style={{ width: '140px', padding: '8px 12px', flexShrink: 0, fontFamily: 'IBM Plex Mono, monospace', fontSize: '10px', color: currentTheme.textSecondary, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{node.id}</div>
                      <div style={{ flex: 1, padding: '8px 12px', minWidth: '200px', fontSize: '12px', color: currentTheme.textPrimary, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                        {getNodeText(node).substring(0, 100)}{getNodeText(node).length > 100 ? '...' : ''}
                      </div>
                      <div style={{ width: '100px', padding: '8px 12px', flexShrink: 0 }}>
                        <span style={{ color: node.confidence === 'high' ? '#10b981' : node.confidence === 'medium' ? '#f59e0b' : '#ef4444', fontSize: '11px' }}>{node.confidence || 'N/A'}</span>
                      </div>
                      <div style={{ width: '100px', padding: '8px 12px', flexShrink: 0, color: currentTheme.textMuted, fontSize: '11px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{node.anchor?.display_location || '‚Äî'}</div>
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
          <div style={{ padding: '8px 12px', background: theme === 'dark' ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.03)', borderTop: `1px solid ${currentTheme.cardBorder}`, fontSize: '11px', color: currentTheme.textMuted, textAlign: 'center' }}>
            Showing {nodes.length} nodes
          </div>
        </div>
      );
    }

    // ============================================================================
    // EXPORT DROPDOWN
    // ============================================================================
    function ExportDropdown({ graphData, svgRef, stats }) {
      const [isOpen, setIsOpen] = useState(false);
      const exportJSON = () => {
        if (!graphData) return;
        const blob = new Blob([JSON.stringify(graphData, null, 2)], { type: 'application/json' });
        const link = document.createElement('a');
        link.download = `legal-graph-${graphData?.case_id || 'export'}.json`;
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(link.href);
        setIsOpen(false);
      };
      const exportSVG = () => {
        if (!svgRef.current) return;
        const svgData = new XMLSerializer().serializeToString(svgRef.current);
        const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
        const link = document.createElement('a');
        link.download = `legal-graph-${graphData?.case_id || 'export'}.svg`;
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(link.href);
        setIsOpen(false);
      };
      return (
        <div style={{ position: 'relative' }}>
          <button onClick={() => setIsOpen(!isOpen)} style={{ padding: '6px 12px', background: 'rgba(168,85,247,0.2)', border: '1px solid rgba(168,85,247,0.4)', borderRadius: '6px', color: '#d8b4fe', fontSize: '12px', cursor: 'pointer' }}>
            üì§ Export
          </button>
          {isOpen && (
            <div style={{ position: 'absolute', top: '100%', right: 0, marginTop: '4px', background: 'rgba(30,30,50,0.98)', border: '1px solid rgba(168,85,247,0.3)', borderRadius: '8px', padding: '6px', minWidth: '160px', zIndex: 1000 }}>
              <button onClick={exportSVG} style={{ width: '100%', padding: '10px 12px', background: 'transparent', border: 'none', color: '#e5e7eb', fontSize: '13px', cursor: 'pointer', textAlign: 'left', borderRadius: '6px' }}
                onMouseEnter={e => e.target.style.background = 'rgba(255,255,255,0.1)'} onMouseLeave={e => e.target.style.background = 'transparent'}>
                üìê Export SVG
              </button>
              <button onClick={exportJSON} style={{ width: '100%', padding: '10px 12px', background: 'transparent', border: 'none', color: '#e5e7eb', fontSize: '13px', cursor: 'pointer', textAlign: 'left', borderRadius: '6px' }}
                onMouseEnter={e => e.target.style.background = 'rgba(255,255,255,0.1)'} onMouseLeave={e => e.target.style.background = 'transparent'}>
                üìã JSON Export
              </button>
            </div>
          )}
        </div>
      );
    }

    // ============================================================================
    // MINIMAP
    // ============================================================================
    function Minimap({ nodes, edges, width = 150, height = 100, zoomTransform, containerRef, zoomRef }) {
      const minimapRef = useRef(null);
      useEffect(() => {
        if (!minimapRef.current || !nodes.length) return;
        const svg = d3.select(minimapRef.current);
        svg.selectAll('*').remove();
        const positionedNodes = nodes.filter(n => n.x !== undefined && n.y !== undefined);
        if (!positionedNodes.length) return;
        const xExtent = d3.extent(positionedNodes, d => d.x);
        const yExtent = d3.extent(positionedNodes, d => d.y);
        if (xExtent[0] === undefined) return;
        const padding = 10;
        const scaleX = (width - padding * 2) / ((xExtent[1] - xExtent[0]) || 1);
        const scaleY = (height - padding * 2) / ((yExtent[1] - yExtent[0]) || 1);
        const scale = Math.min(scaleX, scaleY);
        const offsetX = padding - xExtent[0] * scale + (width - padding * 2 - (xExtent[1] - xExtent[0]) * scale) / 2;
        const offsetY = padding - yExtent[0] * scale + (height - padding * 2 - (yExtent[1] - yExtent[0]) * scale) / 2;

        svg.selectAll('line').data(edges.filter(e => e.source?.x && e.target?.x)).enter().append('line')
          .attr('x1', d => d.source.x * scale + offsetX).attr('y1', d => d.source.y * scale + offsetY)
          .attr('x2', d => d.target.x * scale + offsetX).attr('y2', d => d.target.y * scale + offsetY)
          .attr('stroke', '#4b5563').attr('stroke-width', 0.5);
        svg.selectAll('circle').data(positionedNodes).enter().append('circle')
          .attr('cx', d => d.x * scale + offsetX).attr('cy', d => d.y * scale + offsetY)
          .attr('r', 2).attr('fill', d => NODE_COLORS[d.nodeType || d.type]?.border || '#666');
        if (zoomTransform && containerRef.current) {
          const cw = containerRef.current.clientWidth, ch = containerRef.current.clientHeight;
          svg.append('rect')
            .attr('x', (-zoomTransform.x / zoomTransform.k) * scale + offsetX)
            .attr('y', (-zoomTransform.y / zoomTransform.k) * scale + offsetY)
            .attr('width', (cw / zoomTransform.k) * scale)
            .attr('height', (ch / zoomTransform.k) * scale)
            .attr('fill', 'none').attr('stroke', '#a855f7').attr('stroke-width', 1.5).attr('rx', 2);
        }
      }, [nodes, edges, width, height, zoomTransform, containerRef]);
      return <svg ref={minimapRef} width={width} height={height} style={{ background: 'rgba(0,0,0,0.3)', borderRadius: '6px', cursor: 'pointer' }} />;
    }

    // ============================================================================
    // MAIN COMPONENT
    // ============================================================================
    function LegalGraphVisualizer() {
      const [graphData, setGraphData] = useState(sampleGraph);
      const [ontologyData, setOntologyData] = useState(null);
      const [selectedNode, setSelectedNode] = useState(null);
      const [selectedEdge, setSelectedEdge] = useState(null);
      const [activeTab, setActiveTab] = useState('graph');
      const [filterTypes, setFilterTypes] = useState(new Set(['fact', 'concept', 'issue', 'argument', 'holding', 'precedent', 'outcome', 'justification_set']));
      const [searchQuery, setSearchQuery] = useState('');
      const [highlightedChain, setHighlightedChain] = useState(null);
      const [counterfactualNode, setCounterfactualNode] = useState(null);
      const [fileLoaded, setFileLoaded] = useState(false);
      const [hoveredNode, setHoveredNode] = useState(null);
      const [theme, setTheme] = useState('dark');
      const [zoomTransform, setZoomTransform] = useState(null);
      const [pathFindingMode, setPathFindingMode] = useState(false);
      const [pathSource, setPathSource] = useState(null);
      const [foundPath, setFoundPath] = useState(null);
      const [layoutType, setLayoutType] = useState('force');
      const [maxVisibleNodes, setMaxVisibleNodes] = useState(200);
      const [showAllNodes, setShowAllNodes] = useState(false);
      const [expandedCluster, setExpandedCluster] = useState(null);

      const svgRef = useRef(null);
      const containerRef = useRef(null);
      const searchInputRef = useRef(null);
      const zoomRef = useRef(null);

      const currentTheme = THEMES[theme];

      // ============================================================================
      // DATA PROCESSING
      // ============================================================================
      const allNodes = useMemo(() => {
        if (!graphData) return [];
        const nodes = [
          ...(graphData.facts || []),
          ...(graphData.concepts || []),
          ...(graphData.issues || []),
          ...(graphData.arguments || []),
          ...(graphData.holdings || []),
          ...(graphData.precedents || []),
          ...(graphData.justification_sets || []),
        ];
        if (graphData.outcome) nodes.push(graphData.outcome);
        return nodes;
      }, [graphData]);

      const nodeMap = useMemo(() => {
        const map = new Map();
        allNodes.forEach(n => map.set(n.id, n));
        return map;
      }, [allNodes]);

      // FIX #4: Build edge colors dynamically from loaded data
      const edgeColors = useMemo(() => {
        if (!graphData?.edges) return BASE_EDGE_COLORS;
        const dynamicColors = { ...BASE_EDGE_COLORS };
        const palette = ['#c084fc', '#fb7185', '#fbbf24', '#34d399', '#60a5fa', '#a78bfa', '#f472b6', '#2dd4bf', '#facc15', '#4ade80'];
        let colorIdx = 0;
        graphData.edges.forEach(e => {
          if (e.relation && !dynamicColors[e.relation]) {
            dynamicColors[e.relation] = palette[colorIdx % palette.length];
            colorIdx++;
          }
        });
        return dynamicColors;
      }, [graphData]);

      // Present edge relations from loaded data for legend
      const presentRelations = useMemo(() => {
        if (!graphData?.edges) return [];
        const rels = new Set();
        graphData.edges.forEach(e => { if (e.relation) rels.add(e.relation); });
        return [...rels];
      }, [graphData]);

      const filteredNodes = useMemo(() => {
        return allNodes.filter(n => {
          const type = n.type || getNodeType(n);
          if (!filterTypes.has(type)) return false;
          if (searchQuery) {
            const text = getNodeText(n).toLowerCase();
            if (!text.includes(searchQuery.toLowerCase())) return false;
          }
          return true;
        });
      }, [allNodes, filterTypes, searchQuery]);

      const filteredEdges = useMemo(() => {
        if (!graphData?.edges) return [];
        const nodeIds = new Set(filteredNodes.map(n => n.id));
        return graphData.edges.filter(e => nodeIds.has(e.source) && nodeIds.has(e.target));
      }, [graphData, filteredNodes]);

      // ============================================================================
      // FIX #1: CLUSTER DATA - Build concept clusters from graph data
      // ============================================================================
      const clusters = useMemo(() => {
        if (!graphData) return [];
        // If graph has cluster_summary, use it directly
        if (graphData.cluster_summary) {
          return Object.entries(graphData.cluster_summary).map(([conceptId, cluster]) => ({
            concept_id: conceptId,
            concept_label: cluster.concept_label || getConceptLabel(conceptId),
            logic: cluster.logic || 'and',
            requires: cluster.requires || [],
            satisfied_requirements: cluster.satisfied_requirements || {},
            members: {
              facts: cluster.facts || [], concepts: cluster.concepts || [],
              precedents: cluster.precedents || [], arguments: cluster.arguments || [],
              issues: cluster.issues || [], holdings: cluster.holdings || [],
            },
            memberCount: (cluster.facts?.length || 0) + (cluster.concepts?.length || 0) +
              (cluster.precedents?.length || 0) + (cluster.arguments?.length || 0) +
              (cluster.issues?.length || 0) + (cluster.holdings?.length || 0),
          }));
        }
        // Otherwise, build clusters from concept nodes + edges
        const conceptNodes = graphData.concepts || [];
        if (conceptNodes.length === 0) return [];

        return conceptNodes.map(concept => {
          const cid = concept.id;
          const conceptId = concept.concept_id || cid;
          // Find all nodes connected to this concept via edges
          const connectedIds = new Set();
          (graphData.edges || []).forEach(e => {
            if (e.source === cid) connectedIds.add(e.target);
            if (e.target === cid) connectedIds.add(e.source);
          });
          const members = { facts: [], concepts: [cid], precedents: [], arguments: [], issues: [], holdings: [] };
          connectedIds.forEach(id => {
            const node = nodeMap.get(id);
            if (!node) return;
            const type = getNodeType(node);
            if (members[type + 's']) members[type + 's'].push(id);
            else if (type === 'precedent') members.precedents.push(id);
          });
          // Look up ontology for requirements
          let requires = [], logic = 'and', satisfied = {};
          if (ontologyData?.concepts?.[conceptId]) {
            const ont = ontologyData.concepts[conceptId];
            const rawReqs = ont.requires;
            if (Array.isArray(rawReqs)) {
              logic = rawReqs[0]?.includes('[OR') ? 'or' : 'and';
              requires = rawReqs.filter(r => !r.startsWith('['));
            } else if (typeof rawReqs === 'string') {
              logic = rawReqs.includes('[OR') ? 'or' : 'and';
            }
          }
          return {
            concept_id: conceptId,
            concept_label: getConceptLabel(conceptId, concept),
            logic, requires, satisfied_requirements: satisfied,
            members,
            memberCount: Object.values(members).reduce((s, arr) => s + arr.length, 0),
          };
        }).filter(c => c.memberCount > 1);
      }, [graphData, nodeMap, ontologyData]);

      // ============================================================================
      // FIX #2: HUMAN-READABLE CONCEPT LABELS
      // ============================================================================
      function getConceptLabel(conceptId, node) {
        // Priority: unlisted_label > ontology label > cleaned concept_id
        if (node?.unlisted_label) return node.unlisted_label;
        if (ontologyData?.concepts?.[conceptId]?.label) return ontologyData.concepts[conceptId].label;
        return conceptId?.replace(/_/g, ' ') || '';
      }

      // ============================================================================
      // HELPER FUNCTIONS
      // ============================================================================
      function getNodeType(node) {
        if (node.type) return node.type;
        if (node.fact_type) return 'fact';
        if (node.concept_id) return 'concept';
        if (node.issue_number !== undefined) return 'issue';
        if (node.claim) return 'argument';
        if (node.is_ratio !== undefined) return 'holding';
        if (node.citation) return 'precedent';
        if (node.disposition) return 'outcome';
        if (node.logic && node.target_id) return 'justification_set';
        return 'unknown';
      }

      // FIX #2: Concept labels now prefer unlisted_label
      function getNodeText(node) {
        const type = getNodeType(node);
        switch (type) {
          case 'fact': return node.text || '';
          case 'concept': return node.unlisted_label || getConceptLabel(node.concept_id, node);
          case 'issue': return node.text || '';
          case 'argument': return node.claim || '';
          case 'holding': return node.text || '';
          case 'precedent': return node.citation || node.case_name || '';
          case 'outcome': return node.disposition || '';
          case 'justification_set': return node.label || `JS: ${node.logic?.toUpperCase()} ‚Üí ${node.target_id}`;
          default: return node.id;
        }
      }

      function getNodeLabel(node) {
        const text = getNodeText(node);
        return text.length > 60 ? text.substring(0, 57) + '...' : text;
      }

      // ============================================================================
      // STATS
      // ============================================================================
      const stats = useMemo(() => {
        if (!graphData) return null;
        return {
          facts: (graphData.facts || []).length,
          concepts: (graphData.concepts || []).length,
          issues: (graphData.issues || []).length,
          arguments: (graphData.arguments || []).length,
          holdings: (graphData.holdings || []).length,
          precedents: (graphData.precedents || []).length,
          edges: (graphData.edges || []).length,
          chains: (graphData.reasoning_chains || []).length,
          js: (graphData.justification_sets || []).length,
          warnings: (graphData._meta?.validation_warnings || graphData.validation_warnings || []).length,
          quality: graphData._meta?.quality_tier || graphData.quality_tier || 'unknown'
        };
      }, [graphData]);

      // ============================================================================
      // FILE HANDLING
      // ============================================================================
      const handleFileUpload = (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            setGraphData(data);
            setFileLoaded(true);
            setSelectedNode(null);
            setSelectedEdge(null);
            setHighlightedChain(null);
            setCounterfactualNode(null);
          } catch (err) {
            alert('Invalid JSON file: ' + err.message);
          }
        };
        reader.readAsText(file);
      };

      const handleOntologyUpload = (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            setOntologyData(JSON.parse(e.target.result));
          } catch (err) {
            alert('Invalid ontology JSON: ' + err.message);
          }
        };
        reader.readAsText(file);
      };

      const toggleTheme = useCallback(() => setTheme(prev => prev === 'dark' ? 'light' : 'dark'), []);

      // Zoom controls
      const zoomIn = useCallback(() => { if (svgRef.current && zoomRef.current) d3.select(svgRef.current).transition().duration(300).call(zoomRef.current.scaleBy, 1.3); }, []);
      const zoomOut = useCallback(() => { if (svgRef.current && zoomRef.current) d3.select(svgRef.current).transition().duration(300).call(zoomRef.current.scaleBy, 0.7); }, []);
      const fitToScreen = useCallback(() => {
        if (!svgRef.current || !zoomRef.current || !containerRef.current) return;
        const svg = d3.select(svgRef.current);
        const bounds = svg.select('g').node()?.getBBox();
        if (!bounds) return;
        const w = containerRef.current.clientWidth, h = containerRef.current.clientHeight, p = 50;
        const scale = Math.min((w - p * 2) / bounds.width, (h - p * 2) / bounds.height, 2);
        const tx = w / 2 - scale * (bounds.x + bounds.width / 2);
        const ty = h / 2 - scale * (bounds.y + bounds.height / 2);
        svg.transition().duration(500).call(zoomRef.current.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
      }, []);
      const resetView = useCallback(() => {
        if (!svgRef.current || !zoomRef.current || !containerRef.current) return;
        const w = containerRef.current.clientWidth, h = containerRef.current.clientHeight;
        d3.select(svgRef.current).transition().duration(500).call(zoomRef.current.transform, d3.zoomIdentity.translate(w / 2, h / 2).scale(0.8));
      }, []);

      // BFS path finding
      const findPath = useCallback((startId, endId) => {
        if (!graphData?.edges) return null;
        const adj = {};
        graphData.edges.forEach(e => {
          if (!adj[e.source]) adj[e.source] = [];
          if (!adj[e.target]) adj[e.target] = [];
          adj[e.source].push({ node: e.target, edge: e.id });
          adj[e.target].push({ node: e.source, edge: e.id });
        });
        const queue = [[startId, [startId], []]];
        const visited = new Set([startId]);
        while (queue.length > 0) {
          const [node, path, edges] = queue.shift();
          if (node === endId) return { nodes: path, edges };
          for (const { node: neighbor, edge } of (adj[node] || [])) {
            if (!visited.has(neighbor)) { visited.add(neighbor); queue.push([neighbor, [...path, neighbor], [...edges, edge]]); }
          }
        }
        return null;
      }, [graphData]);

      // Keyboard shortcuts
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') { if (e.key === 'Escape') e.target.blur(); return; }
          switch (e.key) {
            case 'Escape': setSelectedNode(null); setSelectedEdge(null); setPathFindingMode(false); setPathSource(null); setFoundPath(null); break;
            case '/': e.preventDefault(); searchInputRef.current?.focus(); break;
            case '+': case '=': e.preventDefault(); zoomIn(); break;
            case '-': e.preventDefault(); zoomOut(); break;
            case '0': e.preventDefault(); fitToScreen(); break;
            case '1': setActiveTab('graph'); break;
            case '2': setActiveTab('cluster'); break;
            case '3': setActiveTab('chain'); break;
            case '4': setActiveTab('table'); break;
            case '5': setActiveTab('counterfactual'); break;
            case '6': setActiveTab('source'); break;
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [zoomIn, zoomOut, fitToScreen]);

      // ============================================================================
      // FIX #5: ONTOLOGY-DRIVEN COUNTERFACTUAL
      // ============================================================================
      const counterfactualResult = useMemo(() => {
        if (!counterfactualNode || !graphData) return null;
        const removedId = counterfactualNode;
        const removedNode = nodeMap.get(removedId);
        const removedType = removedNode ? getNodeType(removedNode) : 'unknown';

        const result = {
          removedNode: removedId,
          removedType,
          brokenRequirements: [],
          affectedHoldings: [],
          unaffectedHoldings: [],
          affectedClusters: [],
          outcomeAffected: false,
        };

        // Check cluster-level requirement breakage
        clusters.forEach(cluster => {
          const allMemberIds = Object.values(cluster.members).flat();
          if (!allMemberIds.includes(removedId)) return;

          const brokenReqs = [];
          if (cluster.satisfied_requirements) {
            Object.entries(cluster.satisfied_requirements).forEach(([req, satisfierId]) => {
              if (satisfierId === removedId) {
                brokenReqs.push(req);
              }
            });
          }

          if (brokenReqs.length > 0 || allMemberIds.includes(removedId)) {
            result.affectedClusters.push({
              concept_id: cluster.concept_id,
              concept_label: cluster.concept_label,
              logic: cluster.logic,
              brokenReqs,
              isFullyBroken: cluster.logic === 'and' && brokenReqs.length > 0,
            });
            result.brokenRequirements.push(...brokenReqs.map(r => ({
              requirement: r,
              cluster: cluster.concept_label,
              logic: cluster.logic,
            })));
          }
        });

        // Check holdings via justification sets
        (graphData.holdings || []).forEach(h => {
          // Find all JS targeting this holding
          const jsForHolding = (graphData.justification_sets || []).filter(js => js.target_id === h.id);
          // Find direct edges from removed node to holding
          const directEdges = (graphData.edges || []).filter(e => e.source === removedId && e.target === h.id);
          // Find edges that are part of JS and include removed node
          const affectedJS = [];
          const unaffectedJS = [];

          jsForHolding.forEach(js => {
            const jsEdges = (graphData.edges || []).filter(e => e.support_group_ids?.includes(js.id));
            const jsMemberIds = jsEdges.map(e => e.source);
            if (jsMemberIds.includes(removedId)) {
              if (js.logic === 'and') {
                affectedJS.push({ js, reason: `AND justification broken ‚Äî removed node was a required member` });
              } else {
                const remaining = jsMemberIds.filter(m => m !== removedId);
                if (remaining.length === 0) {
                  affectedJS.push({ js, reason: 'OR justification ‚Äî no alternatives remain' });
                } else {
                  unaffectedJS.push({ js, reason: `OR justification ‚Äî ${remaining.length} alternative(s) remain` });
                }
              }
            } else {
              unaffectedJS.push({ js, reason: 'Node not in justification set' });
            }
          });

          if (affectedJS.length > 0 && unaffectedJS.filter(u => u.reason !== 'Node not in justification set').length === 0) {
            result.affectedHoldings.push({
              id: h.id,
              text: getNodeText(h),
              reasons: affectedJS.map(a => a.reason),
              isPrimary: affectedJS.some(a => a.js.is_primary),
              jsDetails: affectedJS.map(a => ({ id: a.js.id, logic: a.js.logic, label: a.js.label })),
            });
          } else if (directEdges.length > 0 && jsForHolding.length === 0) {
            result.affectedHoldings.push({ id: h.id, text: getNodeText(h), reasons: ['Direct support removed (no JS defined)'], isPrimary: true, jsDetails: [] });
          } else {
            result.unaffectedHoldings.push(h.id);
          }
        });

        // Check outcome
        const affectedHoldingIds = new Set(result.affectedHoldings.map(a => a.id));
        result.outcomeAffected = (graphData.edges || []).some(e =>
          affectedHoldingIds.has(e.source) && (e.relation === 'determines' || e.relation === 'contributes_to') &&
          (e.target === 'outcome' || e.target === graphData.outcome?.id)
        );

        return result;
      }, [counterfactualNode, graphData, nodeMap, clusters]);

      // Toulmin structure
      const getToulminStructure = useCallback((argumentId) => {
        if (!graphData) return null;
        const grounds = [], warrants = [], backing = [], rebuttals = [];
        (graphData.edges || []).forEach(e => {
          if (e.target === argumentId) {
            const sourceNode = nodeMap.get(e.source);
            if (!sourceNode) return;
            const sourceType = getNodeType(sourceNode);
            if (e.relation === 'supports') {
              if (sourceType === 'fact') grounds.push(sourceNode);
              else if (sourceType === 'concept') warrants.push(sourceNode);
              else if (sourceType === 'precedent') backing.push(sourceNode);
            } else if (['attacks', 'rebuts', 'undercuts'].includes(e.relation)) {
              rebuttals.push(sourceNode);
            }
          }
        });
        return { grounds, warrants, backing, rebuttals };
      }, [graphData, nodeMap]);

      // ============================================================================
      // D3 FORCE GRAPH
      // ============================================================================
      useEffect(() => {
        if (!svgRef.current || !containerRef.current || activeTab !== 'graph') return;
        const container = containerRef.current;
        const width = container.clientWidth, height = container.clientHeight;
        d3.select(svgRef.current).selectAll('*').remove();
        const svg = d3.select(svgRef.current).attr('width', width).attr('height', height);
        const g = svg.append('g');
        const zoom = d3.zoom().scaleExtent([0.1, 4]).on('zoom', (event) => { g.attr('transform', event.transform); setZoomTransform(event.transform); });
        zoomRef.current = zoom;
        svg.call(zoom);

        let nodesToRender = filteredNodes;
        if (!showAllNodes && filteredNodes.length > maxVisibleNodes) {
          const priorityOrder = { outcome: 0, holding: 1, issue: 2, argument: 3, concept: 4, precedent: 5, fact: 6, justification_set: 7 };
          const criticalNodeIds = new Set(graphData?.reasoning_chains?.flatMap(c => c.critical_nodes || []) || []);
          nodesToRender = [...filteredNodes]
            .sort((a, b) => {
              const aIsCritical = criticalNodeIds.has(a.id) ? 0 : 1;
              const bIsCritical = criticalNodeIds.has(b.id) ? 0 : 1;
              if (aIsCritical !== bIsCritical) return aIsCritical - bIsCritical;
              return (priorityOrder[getNodeType(a)] || 10) - (priorityOrder[getNodeType(b)] || 10);
            }).slice(0, maxVisibleNodes);
        }

        const nodes = nodesToRender.map(n => ({ ...n, nodeType: getNodeType(n) }));
        const nodeIds = new Set(nodes.map(n => n.id));
        const links = filteredEdges.filter(e => nodeIds.has(e.source) && nodeIds.has(e.target)).map(e => ({ ...e }));

        // Layout
        let simulation;
        if (layoutType === 'force') {
          simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links).id(d => d.id).distance(120))
            .force('charge', d3.forceManyBody().strength(-400))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(50));
        } else if (layoutType === 'hierarchical') {
          const typeY = { fact: 0, concept: 0.2, issue: 0.3, precedent: 0.35, argument: 0.5, holding: 0.75, justification_set: 0.6, outcome: 1 };
          nodes.forEach((n, i) => { n.y = (typeY[n.nodeType] || 0.5) * height * 0.8 + 50; n.x = (i % Math.ceil(Math.sqrt(nodes.length))) * (width / Math.ceil(Math.sqrt(nodes.length))) + 50; });
          simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links).id(d => d.id).distance(80).strength(0.5))
            .force('charge', d3.forceManyBody().strength(-200))
            .force('y', d3.forceY(d => (typeY[d.nodeType] || 0.5) * height * 0.8 + 50).strength(0.8))
            .force('x', d3.forceX(width / 2).strength(0.05))
            .force('collision', d3.forceCollide().radius(40));
        } else if (layoutType === 'concept-cluster') {
          // FIX #1: TRUE CONCEPT-CENTRIC CLUSTER LAYOUT
          const conceptPositions = {};
          const conceptNodes = nodes.filter(n => n.nodeType === 'concept');
          const anglePer = (2 * Math.PI) / Math.max(conceptNodes.length, 1);
          const clusterRadius = Math.min(width, height) * 0.3;
          conceptNodes.forEach((c, i) => {
            const angle = anglePer * i - Math.PI / 2;
            conceptPositions[c.id] = { x: width / 2 + clusterRadius * Math.cos(angle), y: height / 2 + clusterRadius * Math.sin(angle) };
          });
          // Assign each node to its nearest concept via edges
          nodes.forEach(n => {
            if (n.nodeType === 'concept') return;
            if (n.nodeType === 'outcome') return;
            const connectedConcepts = (graphData?.edges || [])
              .filter(e => (e.source === n.id || e.target === n.id))
              .map(e => e.source === n.id ? e.target : e.source)
              .filter(id => conceptPositions[id]);
            if (connectedConcepts.length > 0) {
              const pos = conceptPositions[connectedConcepts[0]];
              n._clusterX = pos.x;
              n._clusterY = pos.y;
            }
          });
          simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links).id(d => d.id).distance(60).strength(0.4))
            .force('charge', d3.forceManyBody().strength(-200))
            .force('x', d3.forceX(d => {
              if (d.nodeType === 'outcome') return width / 2;
              if (d.nodeType === 'concept') return conceptPositions[d.id]?.x || width / 2;
              return d._clusterX || width / 2;
            }).strength(0.6))
            .force('y', d3.forceY(d => {
              if (d.nodeType === 'outcome') return height / 2;
              if (d.nodeType === 'concept') return conceptPositions[d.id]?.y || height / 2;
              return d._clusterY || height / 2;
            }).strength(0.6))
            .force('collision', d3.forceCollide().radius(35));
        } else if (layoutType === 'radial') {
          const outcomeNode = nodes.find(n => n.nodeType === 'outcome');
          if (outcomeNode) { outcomeNode.fx = width / 2; outcomeNode.fy = height / 2; }
          simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links).id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('radial', d3.forceRadial(d => {
              if (d.nodeType === 'outcome') return 0;
              if (d.nodeType === 'holding') return 100;
              if (d.nodeType === 'argument' || d.nodeType === 'justification_set') return 180;
              if (d.nodeType === 'concept' || d.nodeType === 'issue') return 260;
              return 340;
            }, width / 2, height / 2).strength(0.8))
            .force('collision', d3.forceCollide().radius(35));
        } else {
          simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links).id(d => d.id).distance(120))
            .force('charge', d3.forceManyBody().strength(-400))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(50));
        }

        // Defs: arrow markers for ALL relations (FIX #4)
        const defs = svg.append('defs');
        // Default marker
        defs.append('marker').attr('id', 'arrow-default').attr('viewBox', '0 -5 10 10').attr('refX', 28).attr('refY', 0).attr('markerWidth', 8).attr('markerHeight', 8).attr('orient', 'auto')
          .append('path').attr('fill', '#6b7280').attr('d', 'M0,-4L8,0L0,4Z');
        // Markers for all known relations
        Object.entries(edgeColors).forEach(([relation, color]) => {
          if (relation === 'default') return;
          defs.append('marker').attr('id', `arrow-${relation}`).attr('viewBox', '0 -5 10 10').attr('refX', 28).attr('refY', 0).attr('markerWidth', 8).attr('markerHeight', 8).attr('orient', 'auto')
            .append('path').attr('fill', color).attr('d', 'M0,-4L8,0L0,4Z');
        });
        // Glow filter
        const glowFilter = defs.append('filter').attr('id', 'glow').attr('x', '-50%').attr('y', '-50%').attr('width', '200%').attr('height', '200%');
        glowFilter.append('feGaussianBlur').attr('stdDeviation', '3').attr('result', 'coloredBlur');
        const glowMerge = glowFilter.append('feMerge');
        glowMerge.append('feMergeNode').attr('in', 'coloredBlur');
        glowMerge.append('feMergeNode').attr('in', 'SourceGraphic');

        // Edges
        const linkGroup = g.append('g').attr('class', 'links');
        const link = linkGroup.selectAll('path').data(links).enter().append('path')
          .attr('fill', 'none')
          .attr('stroke', d => {
            if (foundPath?.edges?.includes(d.id)) return '#f59e0b';
            return edgeColors[d.relation] || edgeColors.default;
          })
          .attr('stroke-width', d => {
            if (foundPath?.edges?.includes(d.id)) return 4;
            return d.is_critical ? 3 : d.strength === 'strong' ? 2 : 1;
          })
          .attr('stroke-opacity', d => {
            if (foundPath?.edges?.includes(d.id)) return 1;
            if (highlightedChain) {
              const chain = graphData.reasoning_chains?.find(c => c.id === highlightedChain);
              return chain?.edge_ids?.includes(d.id) ? 1 : 0.15;
            }
            return 0.7;
          })
          .attr('stroke-dasharray', d => d.strength === 'weak' ? '4,4' : null)
          .attr('marker-end', d => {
            // FIX #4: Use default marker if relation-specific marker not defined
            const markerId = edgeColors[d.relation] ? `arrow-${d.relation}` : 'arrow-default';
            return `url(#${markerId})`;
          })
          .style('cursor', 'pointer')
          .on('click', (event, d) => { event.stopPropagation(); setSelectedEdge(d); setSelectedNode(null); })
          .on('mouseenter', function(event, d) { d3.select(this).attr('stroke-width', d.is_critical ? 5 : 4); })
          .on('mouseleave', function(event, d) { d3.select(this).attr('stroke-width', foundPath?.edges?.includes(d.id) ? 4 : d.is_critical ? 3 : d.strength === 'strong' ? 2 : 1); });

        // Edge labels
        const edgeLabels = linkGroup.selectAll('text').data(links).enter().append('text')
          .text(d => d.relation)
          .attr('font-size', '9px').attr('fill', '#6b7280').attr('text-anchor', 'middle').attr('dy', -6)
          .style('pointer-events', 'none').style('opacity', 0);

        // Nodes
        const nodeGroup = g.append('g').attr('class', 'nodes');
        const node = nodeGroup.selectAll('g').data(nodes).enter().append('g').style('cursor', 'pointer')
          .call(d3.drag()
            .on('start', (event, d) => { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
            .on('drag', (event, d) => { d.fx = event.x; d.fy = event.y; })
            .on('end', (event, d) => { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; })
          )
          .on('click', (event, d) => {
            event.stopPropagation();
            if (pathFindingMode) {
              if (!pathSource) { setPathSource(d.id); }
              else { setFoundPath(findPath(pathSource, d.id)); setPathSource(null); setPathFindingMode(false); }
            } else { setSelectedNode(d); setSelectedEdge(null); }
          })
          .on('mouseenter', (event, d) => { setHoveredNode(d); })
          .on('mouseleave', () => { setHoveredNode(null); });

        // Node shapes: diamond for JS, circle for rest
        node.each(function(d) {
          const el = d3.select(this);
          const colors = NODE_COLORS[d.nodeType] || NODE_COLORS.fact;
          if (d.nodeType === 'justification_set') {
            el.append('rect').attr('width', 24).attr('height', 24).attr('x', -12).attr('y', -12)
              .attr('transform', 'rotate(45)')
              .attr('rx', 3).attr('fill', colors.bg).attr('stroke', colors.border).attr('stroke-width', 2);
          } else {
            const r = d.nodeType === 'outcome' ? 22 : d.nodeType === 'holding' ? 18 : 14;
            el.append('circle').attr('r', r).attr('fill', colors.bg).attr('stroke', colors.border).attr('stroke-width', 2)
              .attr('filter', d.novel ? 'url(#glow)' : null);
          }
        });

        // Node labels
        node.append('text')
          .text(d => {
            const text = getNodeText(d);
            return text.length > 20 ? text.substring(0, 18) + '‚Ä¶' : text;
          })
          .attr('text-anchor', 'middle').attr('dy', d => {
            const r = d.nodeType === 'outcome' ? 22 : d.nodeType === 'holding' ? 18 : d.nodeType === 'justification_set' ? 18 : 14;
            return r + 14;
          })
          .attr('font-size', '10px')
          .attr('fill', d => NODE_COLORS[d.nodeType]?.text || '#ccc')
          .style('pointer-events', 'none');

        // Tick
        simulation.on('tick', () => {
          link.attr('d', d => {
            const dx = d.target.x - d.source.x, dy = d.target.y - d.source.y;
            const dr = Math.sqrt(dx * dx + dy * dy) * 2;
            return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
          });
          edgeLabels.attr('x', d => (d.source.x + d.target.x) / 2).attr('y', d => (d.source.y + d.target.y) / 2);
          node.attr('transform', d => `translate(${d.x},${d.y})`);
        });

        svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity.translate(width / 2, height / 2).scale(0.8));

        return () => simulation.stop();
      }, [filteredNodes, filteredEdges, activeTab, layoutType, highlightedChain, foundPath, showAllNodes, maxVisibleNodes, edgeColors]);

      // ============================================================================
      // RENDER
      // ============================================================================
      return (
        <div style={{ width: '100vw', height: '100vh', display: 'flex', flexDirection: 'column', background: currentTheme.bg, color: currentTheme.textPrimary }}>
          {/* HEADER */}
          <header style={{
            display: 'flex', alignItems: 'center', justifyContent: 'space-between',
            padding: '12px 20px', background: currentTheme.headerBg,
            borderBottom: `1px solid ${currentTheme.borderColor}`, gap: '16px', flexShrink: 0
          }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '14px' }}>
              <span style={{ fontSize: '20px' }}>‚öñÔ∏è</span>
              <div>
                <div style={{ fontSize: '15px', fontWeight: 600 }}>
                  {graphData?.case_name || graphData?.case_id || 'Legal Reasoning Graph'}
                </div>
                <div style={{ fontSize: '11px', color: currentTheme.textMuted }}>
                  {graphData?.court} {graphData?.case_year ? `(${graphData.case_year})` : ''} ‚Ä¢ {stats?.facts || 0}F {stats?.concepts || 0}C {stats?.edges || 0}E {stats?.js || 0}JS
                  {stats?.quality && stats.quality !== 'unknown' && (
                    <span style={{ marginLeft: '8px', padding: '2px 6px', background: QUALITY_COLORS[stats.quality]?.bg || '#333', border: `1px solid ${QUALITY_COLORS[stats.quality]?.border || '#666'}`, borderRadius: '8px', color: QUALITY_COLORS[stats.quality]?.text || '#ccc', fontSize: '10px' }}>
                      {stats.quality}
                    </span>
                  )}
                </div>
              </div>
            </div>
            <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
              {/* Layout selector */}
              <select value={layoutType} onChange={e => setLayoutType(e.target.value)} style={{
                padding: '6px 10px', background: currentTheme.inputBg, border: `1px solid ${currentTheme.inputBorder}`,
                borderRadius: '6px', color: currentTheme.textPrimary, fontSize: '12px'
              }}>
                <option value="force">Force Layout</option>
                <option value="concept-cluster">Concept Cluster</option>
                <option value="hierarchical">Hierarchical</option>
                <option value="radial">Radial</option>
              </select>

              <ExportDropdown graphData={graphData} svgRef={svgRef} stats={stats} />
              <button onClick={toggleTheme} style={{ padding: '6px 12px', background: currentTheme.inputBg, border: `1px solid ${currentTheme.inputBorder}`, borderRadius: '6px', color: currentTheme.textPrimary, fontSize: '12px', cursor: 'pointer' }}>
                {theme === 'dark' ? '‚òÄÔ∏è' : 'üåô'}
              </button>

              <label style={{ display: 'flex', alignItems: 'center', gap: '6px', padding: '6px 12px', background: 'rgba(59,130,246,0.2)', border: '1px solid rgba(59,130,246,0.4)', borderRadius: '6px', cursor: 'pointer', fontSize: '12px', color: '#93c5fd' }}>
                üìÇ Load Graph
                <input type="file" accept=".json" onChange={handleFileUpload} style={{ display: 'none' }} />
              </label>
              <label style={{ display: 'flex', alignItems: 'center', gap: '6px', padding: '6px 12px', background: 'rgba(168,85,247,0.2)', border: '1px solid rgba(168,85,247,0.4)', borderRadius: '6px', cursor: 'pointer', fontSize: '12px', color: '#d8b4fe' }}>
                üìñ Load Ontology
                <input type="file" accept=".json" onChange={handleOntologyUpload} style={{ display: 'none' }} />
              </label>
            </div>
          </header>

          {/* MAIN CONTENT */}
          <div style={{ display: 'flex', flex: 1, overflow: 'hidden' }}>

            {/* LEFT SIDEBAR */}
            <aside style={{ width: '280px', background: currentTheme.sidebarBg, borderRight: `1px solid ${currentTheme.borderColor}`, display: 'flex', flexDirection: 'column', overflow: 'auto' }}>
              {/* Search */}
              <div style={{ padding: '16px', borderBottom: `1px solid ${currentTheme.cardBorder}` }}>
                <input ref={searchInputRef} type="text" placeholder="üîç Search nodes... (/ or Ctrl+F)" value={searchQuery} onChange={e => setSearchQuery(e.target.value)} style={{
                  width: '100%', padding: '10px 14px', background: currentTheme.inputBg, border: `1px solid ${currentTheme.inputBorder}`, borderRadius: '8px', color: currentTheme.textPrimary, fontSize: '13px', outline: 'none'
                }} />
              </div>

              {/* FIX #3: Node Type Filters - NOW includes justification_set */}
              <div style={{ padding: '16px', borderBottom: `1px solid ${currentTheme.cardBorder}` }}>
                <h3 style={{ margin: '0 0 12px 0', fontSize: '13px', color: currentTheme.textSecondary, textTransform: 'uppercase', letterSpacing: '0.5px' }}>Node Types</h3>
                {Object.entries(NODE_COLORS).map(([type, colors]) => (
                  <label key={type} style={{ display: 'flex', alignItems: 'center', gap: '10px', padding: '8px 10px', marginBottom: '4px', borderRadius: '6px', cursor: 'pointer', background: filterTypes.has(type) ? currentTheme.cardBg : 'transparent', color: currentTheme.textPrimary, transition: 'all 0.15s' }}>
                    <input type="checkbox" checked={filterTypes.has(type)} onChange={e => { const s = new Set(filterTypes); if (e.target.checked) s.add(type); else s.delete(type); setFilterTypes(s); }} style={{ accentColor: colors.border }} />
                    <span style={{ color: colors.text, fontSize: '13px' }}>{colors.icon} {type === 'justification_set' ? 'Justification Set' : type.charAt(0).toUpperCase() + type.slice(1)}</span>
                    <span style={{ marginLeft: 'auto', background: colors.bg, border: `1px solid ${colors.border}`, borderRadius: '10px', padding: '2px 8px', fontSize: '11px', color: colors.text }}>
                      {type === 'fact' ? stats?.facts : type === 'concept' ? stats?.concepts : type === 'issue' ? stats?.issues : type === 'argument' ? stats?.arguments : type === 'holding' ? stats?.holdings : type === 'precedent' ? stats?.precedents : type === 'outcome' ? (graphData?.outcome ? 1 : 0) : type === 'justification_set' ? stats?.js : 0}
                    </span>
                  </label>
                ))}
              </div>

              {/* Stats */}
              {stats && (
                <div style={{ padding: '16px', borderBottom: `1px solid ${currentTheme.cardBorder}` }}>
                  <h3 style={{ margin: '0 0 12px 0', fontSize: '13px', color: currentTheme.textSecondary, textTransform: 'uppercase', letterSpacing: '0.5px' }}>Graph Statistics</h3>
                  <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                    {[
                      { label: 'Edges', value: stats.edges, color: '#3b82f6' },
                      { label: 'Chains', value: stats.chains, color: '#10b981' },
                      { label: 'Clusters', value: clusters.length, color: '#a855f7' },
                      { label: 'JS', value: stats.js, color: '#818cf8' },
                    ].map(s => (
                      <div key={s.label} style={{ background: currentTheme.cardBg, borderRadius: '8px', padding: '10px', textAlign: 'center' }}>
                        <div style={{ fontSize: '18px', fontWeight: 600, color: s.color }}>{s.value}</div>
                        <div style={{ fontSize: '10px', color: currentTheme.textMuted }}>{s.label}</div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Reasoning Chains */}
              {graphData?.reasoning_chains?.length > 0 && (
                <div style={{ padding: '16px', flex: 1, overflow: 'auto' }}>
                  <h3 style={{ margin: '0 0 12px 0', fontSize: '13px', color: currentTheme.textSecondary, textTransform: 'uppercase', letterSpacing: '0.5px' }}>Reasoning Chains</h3>
                  {graphData.reasoning_chains.map((chain, idx) => (
                    <div key={chain.id} onClick={() => setHighlightedChain(highlightedChain === chain.id ? null : chain.id)} style={{
                      padding: '12px', marginBottom: '8px', cursor: 'pointer',
                      background: highlightedChain === chain.id ? 'linear-gradient(135deg, rgba(168,85,247,0.2), rgba(236,72,153,0.2))' : currentTheme.cardBg,
                      border: `1px solid ${highlightedChain === chain.id ? 'rgba(168,85,247,0.5)' : currentTheme.cardBorder}`,
                      borderRadius: '10px', transition: 'all 0.2s'
                    }}>
                      <div style={{ fontSize: '13px', fontWeight: 600, marginBottom: '4px' }}>Chain {idx + 1}</div>
                      <div style={{ fontSize: '11px', color: currentTheme.textMuted }}>
                        {(chain.fact_ids?.length || 0)}F ‚Üí {(chain.concept_ids?.length || 0)}C ‚Üí {(chain.argument_ids?.length || 0)}A ‚Üí H
                      </div>
                    </div>
                  ))}
                  {highlightedChain && (
                    <button onClick={() => setHighlightedChain(null)} style={{ width: '100%', padding: '8px', background: 'rgba(239,68,68,0.1)', border: '1px solid rgba(239,68,68,0.3)', borderRadius: '6px', color: '#fca5a5', fontSize: '12px', cursor: 'pointer', marginTop: '8px' }}>
                      Clear Highlight
                    </button>
                  )}
                </div>
              )}
            </aside>

            {/* CENTER */}
            <main style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
              {/* Tabs */}
              <div style={{ display: 'flex', gap: '4px', padding: '12px 16px', background: theme === 'dark' ? 'rgba(20,20,35,0.8)' : 'rgba(255,255,255,0.8)', borderBottom: `1px solid ${currentTheme.cardBorder}`, flexWrap: 'wrap' }}>
                {[
                  { id: 'graph', label: 'üï∏Ô∏è Graph', key: '1' },
                  { id: 'cluster', label: 'üß© Clusters', key: '2' },
                  { id: 'chain', label: 'üîó Chains', key: '3' },
                  { id: 'table', label: 'üìã Table', key: '4' },
                  { id: 'counterfactual', label: 'üîÆ Counterfactual', key: '5' },
                  { id: 'source', label: 'üìÑ Provenance', key: '6' }
                ].map(tab => (
                  <button key={tab.id} onClick={() => setActiveTab(tab.id)} title={`Press ${tab.key}`} style={{
                    padding: '8px 16px',
                    background: activeTab === tab.id ? 'linear-gradient(135deg, rgba(168,85,247,0.3), rgba(236,72,153,0.3))' : 'transparent',
                    border: `1px solid ${activeTab === tab.id ? 'rgba(168,85,247,0.5)' : currentTheme.cardBorder}`,
                    borderRadius: '6px', color: activeTab === tab.id ? currentTheme.textPrimary : currentTheme.textSecondary,
                    fontSize: '13px', cursor: 'pointer', transition: 'all 0.2s'
                  }}>
                    {tab.label}
                  </button>
                ))}
              </div>

              {/* ================================================================ */}
              {/* GRAPH VIEW */}
              {/* ================================================================ */}
              {activeTab === 'graph' && (
                <div ref={containerRef} style={{ flex: 1, position: 'relative' }}>
                  <svg ref={svgRef} style={{ width: '100%', height: '100%', background: 'transparent' }} />

                  {hoveredNode && (
                    <div style={{ position: 'absolute', top: '16px', left: '50%', transform: 'translateX(-50%)', background: theme === 'dark' ? 'rgba(20,20,35,0.98)' : 'rgba(255,255,255,0.98)', border: `2px solid ${NODE_COLORS[getNodeType(hoveredNode)]?.border || '#666'}`, borderRadius: '12px', padding: '12px 16px', maxWidth: '400px', zIndex: 1000, boxShadow: '0 8px 32px rgba(0,0,0,0.3)', pointerEvents: 'none' }}>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' }}>
                        <span style={{ fontSize: '20px' }}>{NODE_COLORS[getNodeType(hoveredNode)]?.icon}</span>
                        <span style={{ padding: '3px 8px', background: NODE_COLORS[getNodeType(hoveredNode)]?.bg, border: `1px solid ${NODE_COLORS[getNodeType(hoveredNode)]?.border}`, borderRadius: '10px', fontSize: '10px', textTransform: 'uppercase', fontWeight: 600, color: NODE_COLORS[getNodeType(hoveredNode)]?.text }}>{getNodeType(hoveredNode)}</span>
                      </div>
                      <div style={{ fontSize: '13px', color: currentTheme.textPrimary, lineHeight: 1.5 }}>{getNodeText(hoveredNode).substring(0, 150)}{getNodeText(hoveredNode).length > 150 ? '...' : ''}</div>
                      {hoveredNode.anchor?.display_location && <div style={{ marginTop: '6px', fontSize: '11px', color: currentTheme.textMuted }}>üìç {hoveredNode.anchor.display_location}</div>}
                    </div>
                  )}

                  {/* Zoom Controls */}
                  <div style={{ position: 'absolute', bottom: '16px', right: '16px', display: 'flex', flexDirection: 'column', gap: '8px', background: theme === 'dark' ? 'rgba(20,20,35,0.95)' : 'rgba(255,255,255,0.95)', border: `1px solid ${currentTheme.cardBorder}`, borderRadius: '10px', padding: '8px', zIndex: 100 }}>
                    {[
                      { fn: zoomIn, label: '+', color: '#a855f7', title: 'Zoom In' },
                      { fn: zoomOut, label: '‚àí', color: '#a855f7', title: 'Zoom Out' },
                      { fn: fitToScreen, label: '‚ä°', color: '#3b82f6', title: 'Fit' },
                      { fn: resetView, label: '‚Ü∫', color: '#10b981', title: 'Reset' },
                    ].map(b => (
                      <button key={b.label} onClick={b.fn} title={b.title} style={{ width: '36px', height: '36px', background: `${b.color}33`, border: `1px solid ${b.color}66`, borderRadius: '8px', color: b.color, fontSize: '18px', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>{b.label}</button>
                    ))}
                  </div>

                  {/* Progressive loading indicator */}
                  {!showAllNodes && filteredNodes.length > maxVisibleNodes && (
                    <div style={{ position: 'absolute', top: '16px', left: '16px', background: theme === 'dark' ? 'rgba(20,20,35,0.95)' : 'rgba(255,255,255,0.95)', border: `1px solid ${currentTheme.cardBorder}`, borderRadius: '10px', padding: '8px 16px', display: 'flex', alignItems: 'center', gap: '12px', zIndex: 100 }}>
                      <span style={{ fontSize: '12px', color: currentTheme.textSecondary }}>Showing {maxVisibleNodes} of {filteredNodes.length} nodes</span>
                      <button onClick={() => setShowAllNodes(true)} style={{ background: 'rgba(59,130,246,0.2)', border: '1px solid rgba(59,130,246,0.4)', borderRadius: '6px', color: '#3b82f6', padding: '4px 12px', fontSize: '11px', cursor: 'pointer' }}>Load All</button>
                    </div>
                  )}

                  {/* FIX #4: DATA-DRIVEN Edge Legend */}
                  <div style={{ position: 'absolute', bottom: '16px', left: '16px', background: theme === 'dark' ? 'rgba(20,20,35,0.95)' : 'rgba(255,255,255,0.95)', border: `1px solid ${currentTheme.cardBorder}`, borderRadius: '10px', padding: '12px', fontSize: '11px', maxHeight: '200px', overflow: 'auto' }}>
                    <div style={{ fontWeight: 600, marginBottom: '8px', color: currentTheme.textSecondary }}>EDGE TYPES</div>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px 12px' }}>
                      {presentRelations.map(rel => (
                        <div key={rel} style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                          <div style={{ width: '16px', height: '2px', background: edgeColors[rel] || edgeColors.default, flexShrink: 0 }} />
                          <span style={{ color: currentTheme.textSecondary }}>{rel}</span>
                        </div>
                      ))}
                    </div>
                  </div>

                  {/* Minimap */}
                  {filteredNodes.length > 10 && (
                    <div style={{ position: 'absolute', bottom: '70px', right: '16px', background: theme === 'dark' ? 'rgba(20,20,35,0.95)' : 'rgba(255,255,255,0.95)', border: `1px solid ${currentTheme.cardBorder}`, borderRadius: '10px', padding: '8px', zIndex: 100 }}>
                      <div style={{ fontSize: '10px', color: currentTheme.textMuted, marginBottom: '4px', textAlign: 'center' }}>MINIMAP</div>
                      <Minimap nodes={filteredNodes} edges={filteredEdges} width={150} height={100} zoomTransform={zoomTransform} containerRef={containerRef} zoomRef={zoomRef} />
                    </div>
                  )}
                </div>
              )}

              {/* ================================================================ */}
              {/* FIX #1: CLUSTER VIEW - NEW TAB */}
              {/* ================================================================ */}
              {activeTab === 'cluster' && (
                <div style={{ flex: 1, overflow: 'auto', padding: '24px' }}>
                  <div style={{ maxWidth: '1000px' }}>
                    <h3 style={{ margin: '0 0 8px 0', fontSize: '18px', color: currentTheme.textPrimary }}>üß© Concept Clusters</h3>
                    <p style={{ color: currentTheme.textSecondary, marginBottom: '20px', fontSize: '14px' }}>
                      Nodes clustered by legal concept. Each cluster groups all facts, precedents, arguments, and holdings relevant to a single doctrine or legal principle. This is the core of the v4 architecture ‚Äî "far links" disappear because everything legally related is locally adjacent.
                    </p>

                    {clusters.length === 0 ? (
                      <div style={{ textAlign: 'center', color: '#6b7280', paddingTop: '60px' }}>
                        <div style={{ fontSize: '48px', marginBottom: '16px', opacity: 0.3 }}>üß©</div>
                        <div>No clusters found. Load a graph JSON with cluster_summary, or load an ontology to auto-generate clusters from concept edges.</div>
                      </div>
                    ) : (
                      <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
                        {clusters.map(cluster => (
                          <div key={cluster.concept_id} style={{
                            background: 'rgba(255,255,255,0.02)', border: `1px solid ${expandedCluster === cluster.concept_id ? 'rgba(168,85,247,0.5)' : 'rgba(255,255,255,0.1)'}`,
                            borderRadius: '12px', overflow: 'hidden', transition: 'border-color 0.2s'
                          }}>
                            {/* Cluster Header */}
                            <div onClick={() => setExpandedCluster(expandedCluster === cluster.concept_id ? null : cluster.concept_id)} style={{
                              padding: '16px 20px', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                              background: expandedCluster === cluster.concept_id ? 'rgba(168,85,247,0.1)' : 'transparent',
                            }}>
                              <div>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '4px' }}>
                                  <span style={{ fontSize: '16px' }}>‚öñÔ∏è</span>
                                  <span style={{ fontSize: '15px', fontWeight: 600, color: '#d8b4fe' }}>{cluster.concept_label}</span>
                                  <span style={{
                                    padding: '3px 8px', borderRadius: '10px', fontSize: '10px', fontWeight: 600,
                                    background: cluster.logic === 'and' ? 'rgba(239,68,68,0.2)' : 'rgba(16,185,129,0.2)',
                                    color: cluster.logic === 'and' ? '#fca5a5' : '#6ee7b7',
                                    border: `1px solid ${cluster.logic === 'and' ? 'rgba(239,68,68,0.4)' : 'rgba(16,185,129,0.4)'}`
                                  }}>{cluster.logic.toUpperCase()}</span>
                                </div>
                                <div style={{ fontSize: '12px', color: currentTheme.textMuted, fontFamily: 'IBM Plex Mono, monospace' }}>{cluster.concept_id}</div>
                              </div>
                              <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                                <span style={{ fontSize: '12px', color: currentTheme.textMuted }}>{cluster.memberCount} members</span>
                                <span style={{ fontSize: '14px', color: currentTheme.textMuted, transition: 'transform 0.2s', transform: expandedCluster === cluster.concept_id ? 'rotate(180deg)' : 'rotate(0deg)' }}>‚ñº</span>
                              </div>
                            </div>

                            {/* Expanded Cluster Detail */}
                            {expandedCluster === cluster.concept_id && (
                              <div style={{ padding: '0 20px 20px 20px' }}>
                                {/* Requirements */}
                                {cluster.requires.length > 0 && (
                                  <div style={{ marginBottom: '16px' }}>
                                    <div style={{ fontSize: '12px', fontWeight: 600, color: '#f472b6', marginBottom: '8px', textTransform: 'uppercase' }}>
                                      Ontology Requirements ({cluster.logic.toUpperCase()})
                                    </div>
                                    {cluster.requires.map((req, i) => {
                                      const satisfier = cluster.satisfied_requirements?.[req];
                                      const satisfied = satisfier != null;
                                      return (
                                        <div key={i} style={{
                                          display: 'flex', alignItems: 'center', gap: '8px', padding: '8px 12px', marginBottom: '4px',
                                          background: satisfied ? 'rgba(16,185,129,0.1)' : 'rgba(239,68,68,0.08)',
                                          border: `1px solid ${satisfied ? 'rgba(16,185,129,0.3)' : 'rgba(239,68,68,0.2)'}`,
                                          borderRadius: '6px', fontSize: '13px'
                                        }}>
                                          <span>{satisfied ? '‚úì' : '‚úó'}</span>
                                          <span style={{ flex: 1, color: satisfied ? '#6ee7b7' : '#fca5a5' }}>{req}</span>
                                          {satisfier && <span style={{ fontSize: '11px', color: currentTheme.textMuted, fontFamily: 'IBM Plex Mono, monospace' }}>‚Üê {satisfier}</span>}
                                        </div>
                                      );
                                    })}
                                  </div>
                                )}

                                {/* Member nodes by type */}
                                {['facts', 'concepts', 'precedents', 'arguments', 'issues', 'holdings'].map(memberType => {
                                  const ids = cluster.members[memberType] || [];
                                  if (ids.length === 0) return null;
                                  const singularType = memberType === 'precedents' ? 'precedent' : memberType.slice(0, -1);
                                  const colors = NODE_COLORS[singularType] || NODE_COLORS.fact;
                                  return (
                                    <div key={memberType} style={{ marginBottom: '12px' }}>
                                      <div style={{ fontSize: '11px', color: colors.text, marginBottom: '6px', fontWeight: 600, textTransform: 'uppercase' }}>
                                        {colors.icon} {memberType} ({ids.length})
                                      </div>
                                      <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                                        {ids.map(id => {
                                          const node = nodeMap.get(id);
                                          return (
                                            <div key={id} onClick={() => { setSelectedNode(node); setActiveTab('graph'); }} style={{
                                              padding: '6px 10px', background: colors.bg, border: `1px solid ${colors.border}`,
                                              borderRadius: '8px', fontSize: '12px', color: colors.text, cursor: 'pointer',
                                              maxWidth: '300px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap'
                                            }}>
                                              {node ? getNodeText(node).substring(0, 60) : id}
                                            </div>
                                          );
                                        })}
                                      </div>
                                    </div>
                                  );
                                })}
                              </div>
                            )}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
              )}

              {/* ================================================================ */}
              {/* CHAIN VIEW */}
              {/* ================================================================ */}
              {activeTab === 'chain' && (
                <div style={{ flex: 1, overflow: 'auto', padding: '24px' }}>
                  {graphData?.reasoning_chains?.length > 0 ? (
                    graphData.reasoning_chains.map((chain, idx) => (
                      <div key={chain.id} style={{ marginBottom: '32px', background: 'rgba(255,255,255,0.02)', borderRadius: '16px', border: '1px solid rgba(255,255,255,0.1)', padding: '24px' }}>
                        <h3 style={{ margin: '0 0 16px 0', fontSize: '18px', background: 'linear-gradient(90deg, #a855f7, #ec4899)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }}>
                          Reasoning Chain {idx + 1}
                        </h3>
                        {chain.narrative && (
                          <div style={{ background: 'rgba(168,85,247,0.1)', border: '1px solid rgba(168,85,247,0.3)', borderRadius: '10px', padding: '16px', marginBottom: '20px', fontSize: '14px', lineHeight: 1.6, fontStyle: 'italic' }}>
                            {chain.narrative}
                          </div>
                        )}
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                          {['fact_ids', 'concept_ids', 'argument_ids'].map(key => {
                            const ids = chain[key] || [];
                            if (ids.length === 0) return null;
                            const type = key === 'fact_ids' ? 'fact' : key === 'concept_ids' ? 'concept' : 'argument';
                            const colors = NODE_COLORS[type];
                            return (
                              <div key={key}>
                                <div style={{ fontSize: '12px', color: colors.text, marginBottom: '8px', fontWeight: 600 }}>{colors.icon} {type.toUpperCase()}S</div>
                                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
                                  {ids.map(id => { const n = nodeMap.get(id); return n && <div key={id} style={{ background: colors.bg, border: `1px solid ${colors.border}`, borderRadius: '8px', padding: '8px 12px', fontSize: '12px', maxWidth: '300px' }}>{getNodeText(n)}</div>; })}
                                </div>
                              </div>
                            );
                          })}
                          <div style={{ textAlign: 'center', color: '#6b7280', fontSize: '20px' }}>‚Üì</div>
                          {/* Justification Set */}
                          {chain.justification_set_id && (() => {
                            const js = nodeMap.get(chain.justification_set_id);
                            if (!js) return null;
                            return (
                              <div>
                                <div style={{ fontSize: '12px', color: NODE_COLORS.justification_set.text, marginBottom: '8px', fontWeight: 600 }}>‚óÜ JUSTIFICATION SET</div>
                                <div style={{ background: NODE_COLORS.justification_set.bg, border: `1px solid ${NODE_COLORS.justification_set.border}`, borderRadius: '8px', padding: '12px', fontSize: '13px' }}>
                                  <div style={{ fontWeight: 600, marginBottom: '4px' }}>{js.label || js.id}</div>
                                  <div style={{ fontSize: '11px', color: currentTheme.textMuted }}>Logic: {js.logic?.toUpperCase()} ‚Ä¢ Target: {js.target_id} ‚Ä¢ {js.is_primary ? 'PRIMARY' : 'SECONDARY'}</div>
                                </div>
                              </div>
                            );
                          })()}
                          <div style={{ textAlign: 'center', color: '#6b7280', fontSize: '20px' }}>‚Üì</div>
                          {/* Holding */}
                          {chain.holding_id && (() => {
                            const h = nodeMap.get(chain.holding_id);
                            return h && (
                              <div>
                                <div style={{ fontSize: '12px', color: NODE_COLORS.holding.text, marginBottom: '8px', fontWeight: 600 }}>üìú HOLDING</div>
                                <div style={{ background: NODE_COLORS.holding.bg, border: `1px solid ${NODE_COLORS.holding.border}`, borderRadius: '10px', padding: '14px', fontSize: '13px', lineHeight: 1.5 }}>
                                  {getNodeText(h)}
                                  {h.is_ratio && <span style={{ display: 'inline-block', marginLeft: '8px', padding: '2px 6px', background: 'rgba(245,158,11,0.3)', borderRadius: '6px', fontSize: '10px', color: '#fcd34d' }}>RATIO</span>}
                                </div>
                              </div>
                            );
                          })()}
                          {/* Critical nodes */}
                          {chain.critical_nodes?.length > 0 && (
                            <div style={{ marginTop: '8px' }}>
                              <div style={{ fontSize: '11px', color: currentTheme.textMuted, marginBottom: '6px' }}>‚ö° CRITICAL NODES</div>
                              <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                                {chain.critical_nodes.map(id => {
                                  const n = nodeMap.get(id);
                                  const t = n ? getNodeType(n) : 'unknown';
                                  return <span key={id} style={{ padding: '3px 8px', background: NODE_COLORS[t]?.bg || '#333', border: `1px solid ${NODE_COLORS[t]?.border || '#666'}`, borderRadius: '10px', fontSize: '10px', color: NODE_COLORS[t]?.text || '#ccc' }}>{n ? getNodeText(n).substring(0, 30) : id}</span>;
                                })}
                              </div>
                            </div>
                          )}
                        </div>
                      </div>
                    ))
                  ) : (
                    <div style={{ textAlign: 'center', color: '#6b7280', paddingTop: '60px' }}>No reasoning chains defined in this graph</div>
                  )}
                </div>
              )}

              {/* ================================================================ */}
              {/* TABLE VIEW */}
              {/* ================================================================ */}
              {activeTab === 'table' && (
                <VirtualizedTable nodes={filteredNodes} selectedNode={selectedNode} setSelectedNode={setSelectedNode} getNodeType={getNodeType} getNodeText={getNodeText} theme={theme} currentTheme={currentTheme} />
              )}

              {/* ================================================================ */}
              {/* FIX #5: UPGRADED COUNTERFACTUAL */}
              {/* ================================================================ */}
              {activeTab === 'counterfactual' && (
                <div style={{ flex: 1, overflow: 'auto', padding: '24px' }}>
                  <div style={{ maxWidth: '900px' }}>
                    <h3 style={{ margin: '0 0 8px 0', fontSize: '18px', color: currentTheme.textPrimary }}>üîÆ Counterfactual Analysis</h3>
                    <p style={{ color: currentTheme.textSecondary, marginBottom: '20px', fontSize: '14px' }}>
                      Remove any node to see which ontology requirements break, which justification sets fail, and whether the outcome changes. This uses the v4 architecture: AND/OR logic from the ontology drives the analysis.
                    </p>

                    <div style={{ marginBottom: '24px' }}>
                      <label style={{ display: 'block', marginBottom: '8px', fontSize: '13px', color: '#9ca3af' }}>Select Node to Remove:</label>
                      <select value={counterfactualNode || ''} onChange={e => setCounterfactualNode(e.target.value || null)} style={{
                        width: '100%', padding: '12px', background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '8px', color: '#fff', fontSize: '14px'
                      }}>
                        <option value="">-- Select a node --</option>
                        <optgroup label="Concepts">
                          {(graphData?.concepts || []).map(c => <option key={c.id} value={c.id}>{getNodeText(c)}</option>)}
                        </optgroup>
                        <optgroup label="Facts">
                          {(graphData?.facts || []).map(f => <option key={f.id} value={f.id}>{getNodeText(f).substring(0, 80)}</option>)}
                        </optgroup>
                        <optgroup label="Precedents">
                          {(graphData?.precedents || []).map(p => <option key={p.id} value={p.id}>{getNodeText(p)}</option>)}
                        </optgroup>
                        <optgroup label="Arguments">
                          {(graphData?.arguments || []).map(a => <option key={a.id} value={a.id}>{getNodeText(a).substring(0, 80)}</option>)}
                        </optgroup>
                      </select>
                    </div>

                    {counterfactualResult && (
                      <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
                        {/* Outcome Banner */}
                        <div style={{
                          padding: '16px', borderRadius: '10px',
                          background: counterfactualResult.outcomeAffected ? 'rgba(239,68,68,0.2)' : 'rgba(16,185,129,0.2)',
                          border: `1px solid ${counterfactualResult.outcomeAffected ? 'rgba(239,68,68,0.4)' : 'rgba(16,185,129,0.4)'}`
                        }}>
                          <div style={{ fontSize: '16px', fontWeight: 600 }}>
                            {counterfactualResult.outcomeAffected ? '‚ö†Ô∏è OUTCOME WOULD BE AFFECTED' : '‚úì OUTCOME WOULD REMAIN STABLE'}
                          </div>
                          <div style={{ fontSize: '13px', color: '#9ca3af', marginTop: '4px' }}>
                            Removing {counterfactualResult.removedType}: "{nodeMap.get(counterfactualResult.removedNode) ? getNodeText(nodeMap.get(counterfactualResult.removedNode)).substring(0, 60) : counterfactualResult.removedNode}"
                          </div>
                        </div>

                        {/* Broken Requirements */}
                        {counterfactualResult.brokenRequirements.length > 0 && (
                          <div style={{ background: 'rgba(255,255,255,0.02)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '12px', padding: '20px' }}>
                            <h4 style={{ margin: '0 0 12px 0', fontSize: '14px', color: '#f472b6' }}>üîó Broken Ontology Requirements ({counterfactualResult.brokenRequirements.length})</h4>
                            {counterfactualResult.brokenRequirements.map((br, i) => (
                              <div key={i} style={{ display: 'flex', alignItems: 'center', gap: '8px', padding: '10px 12px', marginBottom: '6px', background: 'rgba(239,68,68,0.08)', border: '1px solid rgba(239,68,68,0.2)', borderRadius: '6px' }}>
                                <span style={{ color: '#ef4444' }}>‚úó</span>
                                <div>
                                  <div style={{ fontSize: '13px', color: '#fca5a5' }}>{br.requirement}</div>
                                  <div style={{ fontSize: '11px', color: currentTheme.textMuted }}>Cluster: {br.cluster} ({br.logic.toUpperCase()})</div>
                                </div>
                              </div>
                            ))}
                          </div>
                        )}

                        {/* Affected Clusters */}
                        {counterfactualResult.affectedClusters.length > 0 && (
                          <div style={{ background: 'rgba(255,255,255,0.02)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '12px', padding: '20px' }}>
                            <h4 style={{ margin: '0 0 12px 0', fontSize: '14px', color: '#fbbf24' }}>üß© Affected Clusters ({counterfactualResult.affectedClusters.length})</h4>
                            {counterfactualResult.affectedClusters.map((ac, i) => (
                              <div key={i} style={{ padding: '12px', marginBottom: '8px', background: ac.isFullyBroken ? 'rgba(239,68,68,0.1)' : 'rgba(245,158,11,0.1)', border: `1px solid ${ac.isFullyBroken ? 'rgba(239,68,68,0.3)' : 'rgba(245,158,11,0.3)'}`, borderRadius: '8px' }}>
                                <div style={{ fontWeight: 600, marginBottom: '4px' }}>{ac.concept_label}</div>
                                <div style={{ fontSize: '12px', color: currentTheme.textMuted }}>
                                  Logic: {ac.logic.toUpperCase()} ‚Ä¢ {ac.isFullyBroken ? '‚ùå FULLY BROKEN' : '‚ö†Ô∏è Partially affected'}
                                  {ac.brokenReqs.length > 0 && ` ‚Ä¢ ${ac.brokenReqs.length} req(s) unsatisfied`}
                                </div>
                              </div>
                            ))}
                          </div>
                        )}

                        {/* Affected Holdings */}
                        {counterfactualResult.affectedHoldings.length > 0 && (
                          <div style={{ background: 'rgba(255,255,255,0.02)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '12px', padding: '20px' }}>
                            <h4 style={{ margin: '0 0 12px 0', fontSize: '14px', color: '#ef4444' }}>‚ùå Affected Holdings ({counterfactualResult.affectedHoldings.length})</h4>
                            {counterfactualResult.affectedHoldings.map(ah => (
                              <div key={ah.id} style={{ background: 'rgba(239,68,68,0.1)', border: '1px solid rgba(239,68,68,0.3)', borderRadius: '8px', padding: '12px', marginBottom: '8px' }}>
                                <div style={{ fontWeight: 600, marginBottom: '4px' }}>{ah.id}</div>
                                <div style={{ fontSize: '13px', marginBottom: '6px' }}>{ah.text}</div>
                                {ah.reasons.map((r, i) => <div key={i} style={{ fontSize: '11px', color: '#f87171', marginTop: '2px' }}>‚Üí {r}</div>)}
                                {ah.jsDetails.length > 0 && ah.jsDetails.map(js => (
                                  <div key={js.id} style={{ fontSize: '11px', color: currentTheme.textMuted, marginTop: '4px' }}>
                                    JS: {js.label || js.id} ({js.logic?.toUpperCase()})
                                  </div>
                                ))}
                              </div>
                            ))}
                          </div>
                        )}

                        {/* Unaffected Holdings */}
                        {counterfactualResult.unaffectedHoldings.length > 0 && (
                          <div style={{ background: 'rgba(255,255,255,0.02)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '12px', padding: '20px' }}>
                            <h4 style={{ margin: '0 0 12px 0', fontSize: '14px', color: '#10b981' }}>‚úì Unaffected Holdings ({counterfactualResult.unaffectedHoldings.length})</h4>
                            {counterfactualResult.unaffectedHoldings.map(id => {
                              const n = nodeMap.get(id);
                              return n && <div key={id} style={{ background: 'rgba(16,185,129,0.1)', border: '1px solid rgba(16,185,129,0.3)', borderRadius: '8px', padding: '12px', marginBottom: '8px', fontSize: '13px' }}><strong>{id}</strong>: {getNodeText(n).substring(0, 100)}</div>;
                            })}
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                </div>
              )}

              {/* ================================================================ */}
              {/* FIX #6: UPGRADED SOURCE TEXT / PROVENANCE */}
              {/* ================================================================ */}
              {activeTab === 'source' && (
                <div style={{ flex: 1, overflow: 'auto', padding: '24px' }}>
                  <div style={{ maxWidth: '900px', margin: '0 auto' }}>
                    <h3 style={{ margin: '0 0 8px 0', fontSize: '18px', color: currentTheme.textPrimary }}>üìÑ Source Provenance</h3>
                    <p style={{ color: currentTheme.textSecondary, marginBottom: '20px', fontSize: '14px' }}>
                      Every extracted node is anchored to source text. Click to inspect ‚Äî surface_text shows the exact span from the judgment.
                    </p>

                    {/* Legend */}
                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px', marginBottom: '20px', padding: '12px', background: currentTheme.cardBg, borderRadius: '8px', border: `1px solid ${currentTheme.cardBorder}` }}>
                      {Object.entries(NODE_COLORS).map(([type, colors]) => (
                        <div key={type} style={{ display: 'flex', alignItems: 'center', gap: '4px', padding: '4px 8px', background: colors.bg, border: `1px solid ${colors.border}`, borderRadius: '6px', fontSize: '11px', color: colors.text }}>
                          {colors.icon} {type === 'justification_set' ? 'JS' : type}
                        </div>
                      ))}
                    </div>

                    {/* Document reconstruction with REAL provenance */}
                    <div style={{ background: currentTheme.cardBg, border: `1px solid ${currentTheme.cardBorder}`, borderRadius: '12px', padding: '24px', fontSize: '14px', lineHeight: 1.8, color: currentTheme.textPrimary }}>
                      {(() => {
                        const nodesByLocation = {};
                        allNodes.forEach(node => {
                          const loc = node.anchor?.display_location || 'Unknown';
                          if (!nodesByLocation[loc]) nodesByLocation[loc] = [];
                          nodesByLocation[loc].push(node);
                        });
                        const sortedLocations = Object.keys(nodesByLocation).sort((a, b) => {
                          const aNum = parseInt(a.match(/\d+/)?.[0] || '999');
                          const bNum = parseInt(b.match(/\d+/)?.[0] || '999');
                          return aNum - bNum;
                        });
                        return sortedLocations.map(loc => (
                          <div key={loc} style={{ marginBottom: '24px' }}>
                            <div style={{ fontSize: '12px', fontWeight: 600, color: currentTheme.textMuted, marginBottom: '10px', textTransform: 'uppercase', borderBottom: `1px solid ${currentTheme.cardBorder}`, paddingBottom: '6px' }}>
                              {loc}
                            </div>
                            {nodesByLocation[loc].map(node => {
                              const type = getNodeType(node);
                              const colors = NODE_COLORS[type];
                              const hasSurface = node.anchor?.surface_text;
                              return (
                                <div key={node.id} onClick={() => { setSelectedNode(node); }} style={{
                                  marginBottom: '8px', padding: '10px 14px', cursor: 'pointer',
                                  background: colors?.bg || 'transparent',
                                  borderLeft: `3px solid ${colors?.border || 'transparent'}`,
                                  borderRadius: '0 8px 8px 0', transition: 'all 0.2s'
                                }}>
                                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px' }}>
                                    <span style={{ fontSize: '12px' }}>{colors?.icon}</span>
                                    <span style={{ fontSize: '10px', textTransform: 'uppercase', color: colors?.text, fontWeight: 600 }}>{type}</span>
                                    <span style={{ fontSize: '10px', color: currentTheme.textMuted, fontFamily: 'IBM Plex Mono, monospace' }}>{node.id}</span>
                                    {node.confidence && <span style={{ fontSize: '10px', color: node.confidence === 'high' ? '#10b981' : '#f59e0b' }}>{node.confidence}</span>}
                                  </div>
                                  {/* FIX #6: Show surface_text when available */}
                                  {hasSurface ? (
                                    <div>
                                      <div style={{ fontSize: '13px', color: currentTheme.textPrimary, fontStyle: 'italic', marginBottom: '4px', borderLeft: '2px solid rgba(168,85,247,0.4)', paddingLeft: '10px' }}>
                                        "{node.anchor.surface_text}"
                                      </div>
                                      <div style={{ fontSize: '10px', color: currentTheme.textMuted, fontFamily: 'IBM Plex Mono, monospace' }}>
                                        {node.anchor.doc_id && `doc:${node.anchor.doc_id} `}
                                        {node.anchor.start_char != null && `chars:${node.anchor.start_char}-${node.anchor.end_char}`}
                                        {node.anchor.text_hash && ` hash:${node.anchor.text_hash}`}
                                      </div>
                                    </div>
                                  ) : (
                                    <div style={{ fontSize: '13px', color: currentTheme.textPrimary }}>
                                      {getNodeText(node)}
                                    </div>
                                  )}
                                </div>
                              );
                            })}
                          </div>
                        ));
                      })()}
                    </div>
                  </div>
                </div>
              )}
            </main>

            {/* ================================================================ */}
            {/* RIGHT SIDEBAR - NODE/EDGE DETAILS */}
            {/* ================================================================ */}
            <aside style={{ width: '360px', background: currentTheme.sidebarBg, borderLeft: `1px solid ${currentTheme.borderColor}`, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
              {selectedNode ? (
                <div style={{ flex: 1, overflow: 'auto' }}>
                  <div style={{ padding: '20px', background: NODE_COLORS[getNodeType(selectedNode)]?.bg || '#333', borderBottom: `2px solid ${NODE_COLORS[getNodeType(selectedNode)]?.border || '#666'}` }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '8px', flexWrap: 'wrap' }}>
                      <span style={{ fontSize: '24px' }}>{NODE_COLORS[getNodeType(selectedNode)]?.icon}</span>
                      <span style={{ padding: '4px 12px', background: 'rgba(0,0,0,0.3)', borderRadius: '12px', fontSize: '12px', textTransform: 'uppercase', fontWeight: 600 }}>{getNodeType(selectedNode)}</span>
                      {selectedNode.novel && <span style={{ padding: '4px 10px', background: 'rgba(245,158,11,0.3)', border: '1px solid #f59e0b', borderRadius: '12px', fontSize: '11px', fontWeight: 600, color: '#fcd34d' }}>‚≠ê NOVEL</span>}
                    </div>
                    <div style={{ fontFamily: 'IBM Plex Mono, monospace', fontSize: '12px', color: '#9ca3af' }}>{selectedNode.id}</div>
                  </div>

                  <div style={{ padding: '20px' }}>
                    <div style={{ background: 'rgba(255,255,255,0.03)', borderRadius: '10px', padding: '16px', marginBottom: '20px', fontSize: '14px', lineHeight: 1.6 }}>
                      {getNodeText(selectedNode)}
                    </div>

                    {/* FIX #6: Surface text in detail panel */}
                    {selectedNode.anchor?.surface_text && (
                      <div style={{ marginBottom: '20px' }}>
                        <h4 style={{ margin: '0 0 8px 0', fontSize: '13px', color: '#9ca3af', textTransform: 'uppercase' }}>Source Evidence</h4>
                        <div style={{ background: 'rgba(168,85,247,0.1)', border: '1px solid rgba(168,85,247,0.3)', borderRadius: '8px', padding: '12px', fontSize: '13px', fontStyle: 'italic', lineHeight: 1.6 }}>
                          "{selectedNode.anchor.surface_text}"
                        </div>
                        <div style={{ marginTop: '6px', fontSize: '10px', color: currentTheme.textMuted, fontFamily: 'IBM Plex Mono, monospace' }}>
                          {selectedNode.anchor.doc_id && `doc:${selectedNode.anchor.doc_id} `}
                          {selectedNode.anchor.start_char != null && `chars:${selectedNode.anchor.start_char}-${selectedNode.anchor.end_char} `}
                          {selectedNode.anchor.text_hash && `hash:${selectedNode.anchor.text_hash}`}
                        </div>
                      </div>
                    )}

                    {/* Metadata badges */}
                    {(selectedNode.treatment || selectedNode.answer || selectedNode.schemes?.length > 0 || selectedNode.logic) && (
                      <div style={{ marginBottom: '20px' }}>
                        <h4 style={{ margin: '0 0 10px 0', fontSize: '13px', color: '#9ca3af', textTransform: 'uppercase' }}>Metadata</h4>
                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                          {selectedNode.treatment && (
                            <span style={{ padding: '5px 10px', background: TREATMENT_COLORS[selectedNode.treatment]?.bg || '#3d3d3d', border: `1px solid ${TREATMENT_COLORS[selectedNode.treatment]?.border || '#666'}`, borderRadius: '16px', fontSize: '11px', fontWeight: 600, color: TREATMENT_COLORS[selectedNode.treatment]?.text || '#fff', textTransform: 'uppercase' }}>
                              {selectedNode.treatment}
                            </span>
                          )}
                          {selectedNode.answer && (
                            <span style={{ padding: '5px 10px', background: ANSWER_COLORS[selectedNode.answer]?.bg || '#3d3d3d', border: `1px solid ${ANSWER_COLORS[selectedNode.answer]?.border || '#666'}`, borderRadius: '16px', fontSize: '11px', fontWeight: 600, color: ANSWER_COLORS[selectedNode.answer]?.text || '#fff', textTransform: 'uppercase' }}>
                              Answer: {selectedNode.answer}
                            </span>
                          )}
                          {selectedNode.schemes?.map(s => (
                            <span key={s} style={{ padding: '5px 10px', background: SCHEME_COLORS[s]?.bg || '#3d3d3d', border: `1px solid ${SCHEME_COLORS[s]?.border || '#666'}`, borderRadius: '16px', fontSize: '11px', color: SCHEME_COLORS[s]?.text || '#fff' }}>
                              {s.replace(/_/g, ' ')}
                            </span>
                          ))}
                          {selectedNode.logic && (
                            <span style={{ padding: '5px 10px', background: 'rgba(129,140,248,0.2)', border: '1px solid rgba(129,140,248,0.4)', borderRadius: '16px', fontSize: '11px', fontWeight: 600, color: '#c7d2fe' }}>
                              Logic: {selectedNode.logic.toUpperCase()}
                            </span>
                          )}
                          {selectedNode.is_primary !== undefined && (
                            <span style={{ padding: '5px 10px', background: selectedNode.is_primary ? 'rgba(16,185,129,0.2)' : 'rgba(245,158,11,0.2)', border: `1px solid ${selectedNode.is_primary ? 'rgba(16,185,129,0.4)' : 'rgba(245,158,11,0.4)'}`, borderRadius: '16px', fontSize: '11px', color: selectedNode.is_primary ? '#6ee7b7' : '#fcd34d' }}>
                              {selectedNode.is_primary ? 'PRIMARY' : 'SECONDARY'}
                            </span>
                          )}
                        </div>
                      </div>
                    )}

                    {/* Properties */}
                    <div style={{ display: 'grid', gap: '6px', marginBottom: '20px' }}>
                      {selectedNode.confidence && <PropertyRow label="Confidence" value={selectedNode.confidence} />}
                      {selectedNode.anchor?.display_location && <PropertyRow label="Location" value={selectedNode.anchor.display_location} />}
                      {selectedNode.relevance && <PropertyRow label="Relevance" value={selectedNode.relevance} />}
                      {selectedNode.actor && <PropertyRow label="Actor" value={selectedNode.actor} />}
                      {selectedNode.court_response && <PropertyRow label="Court Response" value={selectedNode.court_response} />}
                      {selectedNode.resolves_issue && <PropertyRow label="Resolves" value={selectedNode.resolves_issue} />}
                      {selectedNode.target_id && <PropertyRow label="Target" value={selectedNode.target_id} />}
                      {selectedNode.concept_id && <PropertyRow label="Concept ID" value={selectedNode.concept_id} />}
                    </div>

                    {getNodeType(selectedNode) === 'argument' && (
                      <ToulminView argumentId={selectedNode.id} getToulmin={getToulminStructure} getNodeText={getNodeText} />
                    )}

                    {/* Connections */}
                    <div>
                      <h4 style={{ margin: '0 0 12px 0', fontSize: '13px', color: '#9ca3af', textTransform: 'uppercase' }}>Connections</h4>
                      <div style={{ marginBottom: '12px' }}>
                        <div style={{ fontSize: '11px', color: '#6b7280', marginBottom: '6px' }}>INCOMING</div>
                        {(graphData?.edges || []).filter(e => e.target === selectedNode.id).map(e => (
                          <EdgeChip key={e.id} edge={e} direction="in" nodeMap={nodeMap} getNodeText={getNodeText} onClick={() => { setSelectedEdge(e); setSelectedNode(null); }} />
                        ))}
                        {(graphData?.edges || []).filter(e => e.target === selectedNode.id).length === 0 && <div style={{ fontSize: '12px', color: '#4b5563' }}>None</div>}
                      </div>
                      <div>
                        <div style={{ fontSize: '11px', color: '#6b7280', marginBottom: '6px' }}>OUTGOING</div>
                        {(graphData?.edges || []).filter(e => e.source === selectedNode.id).map(e => (
                          <EdgeChip key={e.id} edge={e} direction="out" nodeMap={nodeMap} getNodeText={getNodeText} onClick={() => { setSelectedEdge(e); setSelectedNode(null); }} />
                        ))}
                        {(graphData?.edges || []).filter(e => e.source === selectedNode.id).length === 0 && <div style={{ fontSize: '12px', color: '#4b5563' }}>None</div>}
                      </div>
                    </div>
                  </div>
                </div>
              ) : selectedEdge ? (
                <div style={{ flex: 1, overflow: 'auto', padding: '20px' }}>
                  <h3 style={{ margin: '0 0 16px 0', fontSize: '16px' }}>Edge Details</h3>
                  <div style={{ background: 'rgba(255,255,255,0.03)', borderRadius: '10px', padding: '16px', marginBottom: '20px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '12px' }}>
                      <span style={{ padding: '6px 14px', background: edgeColors[selectedEdge.relation] || edgeColors.default, borderRadius: '16px', fontSize: '12px', fontWeight: 600, textTransform: 'uppercase' }}>{selectedEdge.relation}</span>
                      {selectedEdge.is_critical && <span style={{ color: '#f59e0b', fontSize: '12px' }}>‚ö° CRITICAL</span>}
                    </div>
                    <div style={{ fontSize: '13px', color: '#9ca3af' }}>
                      <div style={{ marginBottom: '8px' }}><strong>From:</strong> {selectedEdge.source}</div>
                      <div><strong>To:</strong> {selectedEdge.target}</div>
                    </div>
                  </div>
                  <div style={{ display: 'grid', gap: '8px' }}>
                    <PropertyRow label="Confidence" value={selectedEdge.confidence} />
                    <PropertyRow label="Strength" value={selectedEdge.strength} />
                    {selectedEdge.explanation && <PropertyRow label="Explanation" value={selectedEdge.explanation} />}
                    {selectedEdge.support_group_ids?.length > 0 && <PropertyRow label="Support Groups" value={selectedEdge.support_group_ids.join(', ')} />}
                  </div>
                  <div style={{ marginTop: '20px' }}>
                    <button onClick={() => { const n = nodeMap.get(selectedEdge.source); if (n) { setSelectedNode(n); setSelectedEdge(null); } }} style={{ width: '100%', padding: '10px', background: 'rgba(59,130,246,0.2)', border: '1px solid rgba(59,130,246,0.4)', borderRadius: '8px', color: '#93c5fd', cursor: 'pointer', marginBottom: '8px', fontSize: '13px' }}>View Source Node</button>
                    <button onClick={() => { const n = nodeMap.get(selectedEdge.target); if (n) { setSelectedNode(n); setSelectedEdge(null); } }} style={{ width: '100%', padding: '10px', background: 'rgba(16,185,129,0.2)', border: '1px solid rgba(16,185,129,0.4)', borderRadius: '8px', color: '#6ee7b7', cursor: 'pointer', fontSize: '13px' }}>View Target Node</button>
                  </div>
                </div>
              ) : (
                <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '40px', textAlign: 'center', color: '#6b7280' }}>
                  <div style={{ fontSize: '48px', marginBottom: '16px', opacity: 0.3 }}>üëÜ</div>
                  <div style={{ fontSize: '14px' }}>Click on a node or edge to view details</div>
                  <div style={{ fontSize: '12px', marginTop: '8px', color: '#4b5563' }}>Esc: Deselect ‚Ä¢ /: Search ‚Ä¢ 1-6: Tabs ‚Ä¢ +/-: Zoom</div>
                </div>
              )}
            </aside>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<LegalGraphVisualizer />);
  </script>
</body>
</html>
